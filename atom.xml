<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Craft</title>
  
  <subtitle>Season&#39;s coding world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://code.xnix.me/"/>
  <updated>2018-05-07T08:12:50.108Z</updated>
  <id>http://code.xnix.me/</id>
  
  <author>
    <name>XueSeason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单解释器构造 - Part.2</title>
    <link href="http://code.xnix.me/2018/05/07/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0-Part-2/"/>
    <id>http://code.xnix.me/2018/05/07/简单解释器构造-Part-2/</id>
    <published>2018-05-07T07:16:33.000Z</published>
    <updated>2018-05-07T08:12:50.108Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们可以让解释器稍微复杂点：<br><a id="more"></a></p><ol><li>允许多位数字输入</li><li>添加减法运算</li><li>允许空格字符的输入</li></ol><p>下面是新版本的解释器代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Token types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> INTEGER = <span class="string">'INTEGER'</span></span><br><span class="line"><span class="keyword">const</span> PLUS = <span class="string">'PLUS'</span></span><br><span class="line"><span class="keyword">const</span> MINUS = <span class="string">'MINUS'</span></span><br><span class="line"><span class="keyword">const</span> EOF = <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type, value) &#123;</span><br><span class="line">    <span class="comment">// token type: INTEGER, PLUS or EOF</span></span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="comment">// token value: 0, 1, 2, 3, 4, 8, 9, '+', or None</span></span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * String representation of the class instance.</span></span><br><span class="line"><span class="comment">   * Examples:</span></span><br><span class="line"><span class="comment">   *     Token(INTEGER, 3)</span></span><br><span class="line"><span class="comment">   *     Token(PLUS, +)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Token(<span class="subst">$&#123;<span class="keyword">this</span>.type&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.value&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (text) &#123;</span><br><span class="line">    <span class="comment">// client string input, e.g. "3+5", "12 - 5", etc</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">// this.pos is an index into this.text</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">    <span class="comment">// current token instance</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.currentChar = <span class="keyword">this</span>.text[<span class="keyword">this</span>.pos]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Advance the 'pos' pointer and set the 'current_char' variable.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  advance () &#123;</span><br><span class="line">    <span class="keyword">this</span>.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &gt; <span class="keyword">this</span>.text.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentChar = <span class="literal">null</span> <span class="comment">// Indicates end of input</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentChar = <span class="keyword">this</span>.text[<span class="keyword">this</span>.pos]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  skipWhitespace () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.currentChar !== <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.currentChar === <span class="string">' '</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advance()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return a(multidigit) integer consumed from the input.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  integer () &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.currentChar !== <span class="literal">null</span> &amp;&amp; <span class="built_in">Number</span>.isInteger(+<span class="keyword">this</span>.currentChar)) &#123;</span><br><span class="line">      result += <span class="keyword">this</span>.currentChar</span><br><span class="line">      <span class="keyword">this</span>.advance()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> +result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="comment">   * This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="comment">   * apart into tokens. One part at a time.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getNextToken () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.currentChar !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentChar === <span class="string">' '</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.skipWhitespace()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(+<span class="keyword">this</span>.currentChar)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Token(INTEGER, <span class="keyword">this</span>.integer())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentChar === <span class="string">'+'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advance()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentChar === <span class="string">'-'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advance()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Token(EOF, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat (tokenType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentToken.type === tokenType) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  expr () &#123;</span><br><span class="line">    <span class="comment">// set current token to the first token taken from the input</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// we expect the current token to be a '+' token</span></span><br><span class="line">    <span class="keyword">const</span> op = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">if</span> (op.type === PLUS) &#123;</span><br><span class="line">      <span class="keyword">this</span>.eat(PLUS)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.eat(MINUS)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// after the above call the this.currentToken is set to EOF token</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (op.type === PLUS) &#123;</span><br><span class="line">      result = left.value + right.value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = left.value - right.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">'13 - 1'</span></span><br><span class="line">  <span class="keyword">const</span> interpreter = <span class="keyword">new</span> Interpreter(text)</span><br><span class="line">  <span class="built_in">console</span>.log(interpreter.expr())</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引出一个术语，词义（lexeme）</p><p><img src="https://ruslanspivak.com/lsbasi-part2/lsbasi_part2_lexemes.png" alt="lexeme"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们可以让解释器稍微复杂点：&lt;br&gt;
    
    </summary>
    
    
      <category term="Interpreter" scheme="http://code.xnix.me/tags/Interpreter/"/>
    
  </entry>
  
  <entry>
    <title>简单解释器构造 - Part.1</title>
    <link href="http://code.xnix.me/2018/05/07/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0-Part-1/"/>
    <id>http://code.xnix.me/2018/05/07/简单解释器构造-Part-1/</id>
    <published>2018-05-07T05:54:46.000Z</published>
    <updated>2018-05-07T07:15:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>无论你是新手还是经验丰富的开发者，如果你不知道编译器和解释器的工作原理，你也不会知道计算机是如何工作的。<br><a id="more"></a><br>为什么需要学习解释器和编译器？有三个原因：</p><ol><li>编写一个解释器或者编译器，需要学习并使用大量的技术。这能够帮助你提高技术从而变成一个更好的开发者。同时这些学到的技术，可以运用在其他开发领域。</li><li>你真的非常渴望了解计算机的工作原理。清楚解释器和编译器的构建过程，理解工作原理，让代码更可控。</li><li>你想自创一门编程语言或者 DSL。</li></ol><p>通常我们的程序是用高级语言编写的，计算机并不能理解高级语言，我们需要通过解释器或者编译将高级编程语言转为另一种形式，方便计算机理解。</p><p>将源程序转为机器语言进行处理（计算机可以直接理解的语言）的工具称之为编译器；直接处理高级语言（没有直接转化为机器语言）的工具称之为解释器。</p><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_compiler_interpreter.png" alt="compiler and interpreter"></p><p>下面是 Pascal 的阶乘函数例子：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> factorial;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n: interger)</span>:</span> longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        factorial := <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        factorial := n * factorial(n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n: interger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span> <span class="keyword">to</span> <span class="number">16</span> <span class="keyword">do</span></span><br><span class="line">        writeln(n, <span class="string">'! = '</span>, factorial(n));</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>先为解释器实现一个简单算数表达式，最简单的就是两个整数相加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Token types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> INTEGER = <span class="string">'INTEGER'</span></span><br><span class="line"><span class="keyword">const</span> PLUS = <span class="string">'PLUS'</span></span><br><span class="line"><span class="keyword">const</span> EOF = <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type, value) &#123;</span><br><span class="line">    <span class="comment">// token type: INTEGER, PLUS or EOF</span></span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="comment">// token value: 0, 1, 2, 3, 4, 8, 9, '+', or None</span></span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * String representation of the class instance.</span></span><br><span class="line"><span class="comment">   * Examples:</span></span><br><span class="line"><span class="comment">   *     Token(INTEGER, 3)</span></span><br><span class="line"><span class="comment">   *     Token(PLUS, +)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Token(<span class="subst">$&#123;<span class="keyword">this</span>.type&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.value&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (text) &#123;</span><br><span class="line">    <span class="comment">// client string input, e.g. "3+5"</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">// this.pos is an index into this.text</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">    <span class="comment">// current token instance</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="comment">   * This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="comment">   * apart into tokens. One part at a time.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getNextToken () &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">this</span>.text</span><br><span class="line">    <span class="comment">// is this.pos index past the end of the thsi.text?</span></span><br><span class="line">    <span class="comment">// if so, then return EOF token because there is no more</span></span><br><span class="line">    <span class="comment">// input left to convert into kokens</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &gt; text.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Token(EOF, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get a character at the position this.pos and decide</span></span><br><span class="line">    <span class="comment">// what token to create based on the single character</span></span><br><span class="line">    <span class="keyword">const</span> currentChar = text[<span class="keyword">this</span>.pos]</span><br><span class="line">    <span class="comment">// if the character is a digit then convert it to</span></span><br><span class="line">    <span class="comment">// integer, create an INTEGER token, increment this.pos</span></span><br><span class="line">    <span class="comment">// index to point to the next character after the digit</span></span><br><span class="line">    <span class="comment">// and return the INTEGER token</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(+currentChar)) &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">new</span> Token(INTEGER, +currentChar)</span><br><span class="line">      <span class="keyword">this</span>.pos += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentChar === <span class="string">'+'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">new</span> Token(PLUS, currentChar)</span><br><span class="line">      <span class="keyword">this</span>.pos += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat (tokenType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentToken.type === tokenType) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  expr () &#123;</span><br><span class="line">    <span class="comment">// set current token to the first token taken from the input</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// we expect the current token to be a '+' token</span></span><br><span class="line">    <span class="keyword">const</span> op = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(PLUS)</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// after the above call the this.currentToken is set to EOF token</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = left.value + right.value</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">'3+5'</span></span><br><span class="line">  <span class="keyword">const</span> interpreter = <span class="keyword">new</span> Interpreter(text)</span><br><span class="line">  <span class="built_in">console</span>.log(interpreter.expr()) <span class="comment">// 2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码需要遵守三条规则：</p><ol><li>只允许输入一位数字</li><li>只支持加法操作</li><li>不允许空格字符输入</li></ol><p>为了让解释器能够理解 <code>&quot;3+5&quot;</code>，需要将字符串分解成各组件，这些组件称为 <code>token</code>。Token 是一个对象，拥有 type 和 value 属性。</p><p>将输入的字符串分解成 token 的过程，称为词法分析（lexical analysis），简称 laxer。所以第一步解释器需要读取输入的字符，然后转为 token 流。</p><p>方法 <code>getNextToken</code> 是解释器的词法分析器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'3+5'</span></span><br><span class="line"><span class="keyword">const</span> interpreter = <span class="keyword">new</span> Interpreter(text)</span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'INTEGER', value: 3 &#125;</span></span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'PLUS', value: '+' &#125;</span></span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'INTEGER', value: 5 &#125;</span></span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'EOF', value: null &#125;</span></span><br></pre></td></tr></table></figure><p>方法 <code>expr</code> 确保 token 序列是正确的，如 INTEGER -&gt; PLUS -&gt; INTEGER，然后再进行加法运算。</p><p>以上差不多就是解释器里的 Hello World 例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论你是新手还是经验丰富的开发者，如果你不知道编译器和解释器的工作原理，你也不会知道计算机是如何工作的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interpreter" scheme="http://code.xnix.me/tags/Interpreter/"/>
    
  </entry>
  
  <entry>
    <title>深入 ES Modules（译）</title>
    <link href="http://code.xnix.me/2018/05/04/%E6%B7%B1%E5%85%A5-ES-Modules/"/>
    <id>http://code.xnix.me/2018/05/04/深入-ES-Modules/</id>
    <published>2018-05-04T08:42:19.000Z</published>
    <updated>2018-05-04T08:42:55.919Z</updated>
    
    <content type="html"><![CDATA[<p>ES Modules 使 JS 的模块系统标准化。这一标准化的工作差不多经历了 10 年。</p><p>随着今年 5 月份 Firefox 60 的发布，所有的主流浏览器都将支持 ES Modules。此外 Node.js 团队当前也正在支持 ES Modules。代表 Web 未来的 WebAssembly 也正在集成 ES Modules。</p><p>让我们先看看 ES Modules 解决了什么问题以及和其他模块系统的不同。<br><a id="more"></a></p><h2 id="最初的-JS"><a href="#最初的-JS" class="headerlink" title="最初的 JS"></a>最初的 JS</h2><p>最初 JS 只有函数作用域的概念，函数内部变量对外不可见。</p><p><img src="https://hacks.mozilla.org/files/2018/03/02_module_scope_01-768x448.png" alt="function scope"></p><p>但是不同函数作用域却无法共享变量。最简单的方式，把这个变量放到上一级作用域（比如全局作用域）。</p><p>例如 jQuery，当你需要使用 jQuery 的其他插件库时，必须确保 jQuery 在你的全局作用域里。</p><p><img src="https://hacks.mozilla.org/files/2018/03/02_module_scope_02-768x691.png" alt="global scope"></p><p>这样存在两个不足：</p><ul><li><p><strong>不明确的依赖关系</strong>。项目会变得难以维护，当修改历史代码时，加大整个项目崩溃的不确定性。</p></li><li><p><strong>造成全局变量污染</strong>。由于变量从全局作用域中获取，无法保证这个变量的正确性（可能被其他代码所修改）。</p></li></ul><h2 id="加入模块化后"><a href="#加入模块化后" class="headerlink" title="加入模块化后"></a>加入模块化后</h2><p>模块作用域让内部的变量可以被其他模块获取，其他模块可以明确指定获取哪些变量、类或者函数。</p><p><img src="https://hacks.mozilla.org/files/2018/03/02_module_scope_04-768x691.png" alt="module scope"></p><p>这样完美地解决了上面的两个不足。</p><p>在过去的模块化发展道路上，出现了大量模块化方案，当前 Node.js 所流行的 CommonJS 即将成为历史。ESM 作为新的模块化系统已经被加入了 JS 规范当中。浏览器已经支持了 ES Modules，Node.js 正在支持。</p><h2 id="ES-Modules-工作原理"><a href="#ES-Modules-工作原理" class="headerlink" title="ES Modules 工作原理"></a>ES Modules 工作原理</h2><p>通过 import 语句明确所需要加载的代码：</p><p><img src="https://hacks.mozilla.org/files/2018/03/04_import_graph-768x447.png" alt="dependencies"></p><p>浏览器会先解析文件，创建 Module Record：</p><p><img src="https://hacks.mozilla.org/files/2018/03/05_module_record-768x441.png" alt="Module Record"></p><p>随后 Module Record 需要被转成一个 Module Instance ，Module Instance 主要由<code>代码(code)</code>和<code>状态(state)</code>组成。</p><ul><li>code 是一系列指令，负责执行逻辑。</li><li>state 是指令所需要的计算机资源，通常是内存上保存的值。</li></ul><p>我们可以将 code 看做引擎，state 就是汽油。</p><p><img src="https://hacks.mozilla.org/files/2018/03/06_module_instance-768x572.png" alt="code state"></p><p>我们需要得到每一个 Module 的 Module Instance。整个 Module 的加载过程从一个入口文件开始构造一张完整的 Module Instance 依赖图。</p><p>对于 ES Modules 会进行以下三步骤：</p><ol><li>构造 - 获取文件，将文件解析为 Module Record。</li><li>实例化 - 从内存中申请一个空间（但是并没有进行赋值）。然后将 import 和 export 的变量的指针都指向这个空间地址。称之为链接（linking）。</li><li>赋值 - 运行代码，得到变量实际的值后填充到内存空间。</li></ol><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_3_phases.png" alt="three steps"></p><p>上述三个阶段可以独立执行，这让 ES Modules 能够实现异步加载。但是 ES Modules 也可以同步加载，这取决于加载方式。这里分成两种规格：</p><ul><li>ES module spec，规定了如何构造、实例化和赋值（上述三个步骤），但是并没有规定如何获取到文件。</li><li>Load module spec，不同规格规定了 loader 的加载方式，比如浏览器的 HTML spec。</li></ul><p><img src="https://hacks.mozilla.org/files/2018/03/07_loader_vs_es-768x439.png" alt="spec"></p><p>Loader 可以直接调用 ES Module 的方法 - <code>ParseModule</code>, <code>Module.Instantiate</code>, 和 <code>Module.Evaluate</code>，从而控制 ES Module 的整个实现过程。</p><p><img src="https://hacks.mozilla.org/files/2018/03/08_loader_as_puppeteer-768x507.png" alt="puppeteer"></p><p>下面是更详细的实现细节。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>构造阶段发生三件事：</p><ol><li>Module resolution，也就是获取文件的地址。</li><li>获取文件（通过 URL 下载、从文件系统加载）。</li><li>将文件解析为 Module Record。</li></ol><h3 id="查找并获取文件"><a href="#查找并获取文件" class="headerlink" title="查找并获取文件"></a>查找并获取文件</h3><p>首先从一个入口文件出发。在 HTML 中，通过一个 script 标签告诉 Loader 来查找相关文件。</p><p><img src="https://hacks.mozilla.org/files/2018/03/08_script_entry-768x288.png" alt="entry"></p><p>然后通过代码里的 import 语句中的标识符（module specifier）告诉 Loader 下一个需要加载的 Module。</p><p><img src="https://hacks.mozilla.org/files/2018/03/09_module_specifier-768x161.png" alt="module specifier"></p><h4 id="Module-specifier"><a href="#Module-specifier" class="headerlink" title="Module specifier"></a>Module specifier</h4><p>每一个宿主环境（通常是浏览器和 Node）有各自的 <code>module resolution algorithm</code> 来解释模块标识符字符串。有些模块标识符可以在 Node 环境中工作但是在浏览器中还无法工作，<a href="https://github.com/domenic/package-name-maps" target="_blank" rel="noopener">不过也快了</a>。</p><p>目前浏览器只接受 URL 作为模块标识符，通过 URL 可以加载相关的模块文件。在解析文件前，是无法得知后续需要获取的模块文件；同时在获取到文件前，也无法解析该模块文件。所以浏览器并不会同时加载整个依赖图的所有模块文件。</p><p>也就是说必须先一层层地遍历依赖图，解析一个模块文件，然后得到相关依赖，再查找并加载这些依赖，如此循环。</p><p><img src="https://hacks.mozilla.org/files/2018/03/10_construction-768x464.png" alt="go through"></p><p>如果主线程需要等待每个模块文件的下载（耗时任务），其他任务就会在队列中堆积。</p><p><img src="https://hacks.mozilla.org/files/2018/03/11_latency-768x415.png" alt="long time task"></p><p>主线程被阻塞会让整个应用变得卡顿，这也就是为什么 ES Modules spec 将模块的装载工作分成三个阶段。浏览器便可以异步获取文件，在构造过程中解析文件，得到模块依赖图，然后进行后续的同步实例化工作。</p><p>这也是 ES Modules 和 CommonJS 最关键的不同点。</p><p>CommonJS 并不需要考虑异步，因为在 Node 中是通过文件系统来加载模块文件，这比网络请求要快得多。这就允许 Node 在加载这些文件的时候阻塞主线程。也就是说在返回一个 Module Instance 之前，Node 已经遍历了整个依赖树，同时也完成了实例化和赋值的操作。</p><p><img src="https://hacks.mozilla.org/files/2018/03/12_cjs_require-768x457.png" alt="CommonJS"></p><p>因为 Node 采用 CommonJS 规范，你的模块标识符可以是一个变量（这在 ES Modules 中是不允许的，只有声明和语句才被允许）。同时因为加载是同步过程，同时进行了实例化和赋值操作，得到的变量也能同时得到其值。</p><p>但是 ES Modules 是预先构造好整个依赖图，然后才有赋值操作。这就造成在模块标识符字符串中不能使用变量（此时还没有值）。</p><p><img src="https://hacks.mozilla.org/files/2018/03/13_static_import-768x225.png" alt="variables in module specifiers"></p><p>这一不足，可以通过<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">动态导入（dynamic import）</a>弥补，形如 <code>import(&#96;${path}/foo.js&#96;)</code></p><p>这相当于构造一张新的依赖图，后续处理过程也是独立的。</p><p><img src="https://hacks.mozilla.org/files/2018/03/14dynamic_import_graph-768x597.png" alt="dynamic import"></p><h4 id="共享-Module-Instance"><a href="#共享-Module-Instance" class="headerlink" title="共享 Module Instance"></a>共享 Module Instance</h4><p>Loader 会缓存创建好的 Module Instance，如此一来，当多个模块依赖于一个模块，只会进行一次加载模块文件的操作，这样减少了引擎的压力。</p><p>Loader 会通过 Module Map 来管理这些缓存。</p><p>当需要获取指定模块文件，先将这个 URL 标记为 <strong>fetching</strong> 状态，然后再发送请求并开始下一个获取操作。</p><p><img src="https://hacks.mozilla.org/files/2018/03/15_module_map-768x261.png" alt="fetching"></p><p>如果其他文件依赖了相同的模块文件，Loader 会先遍历 Module Map 里的 URL，当 URL 是 fetching 状态时，直接跳过并开始下一个获取操作。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>获取到文件后，需要将其解析为 Module Record。</p><p><img src="https://hacks.mozilla.org/files/2018/03/25_file_to_module_record-768x306.png" alt="parse"></p><p>Module Record 被创建后，会更新 Module Map。</p><p><img src="https://hacks.mozilla.org/files/2018/03/25_module_map-768x367.png" alt="Module Map"></p><p>ES Module 通过 <strong>parse goal</strong> 来决定解析方式。</p><p>浏览器通过 script 的 type 属性来确定使用解析方式，<code>type=&quot;module&quot;</code> 告诉浏览器以 Module 方式解析。</p><p><img src="https://hacks.mozilla.org/files/2018/03/26_parse_goal-768x477.png" alt="type module"></p><p>但是在 Node 环境中，通常使用 <code>.mjs</code> 扩展名，这一方式还在讨论中，并不是最终方案。</p><p>下一步就开始实例化 Module，并链接所有 Module Instance。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>实例化的过程就是申请内存空间并绑定地址的过程。</p><p>首先 JS 引擎会为 Module Record 创建各自的 Module Environment Record，然后申请内存空间，通过 Module Environment Record 将 Module Record 导出的字段和相关的内存空间绑定。导出的函数声明在这个阶段被初始化，这让后续的赋值操作变得简单。</p><p>模块依赖图中的各个模块通过深度优先算法实例化。</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_01-768x316.png" alt="wire up exports"></p><p>先进行 exports 的链接操作，然后再回到顶层开始 imports 的链接操作。相匹配的 export 和 import 都会指向同一个内存地址</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_02-768x316.png" alt="wire up imports"></p><p>CommonJS 不同于 ES Modules，它的 export 操作会进行拷贝导出。</p><p><img src="https://hacks.mozilla.org/files/2018/03/31_cjs_variable-768x174.png" alt="copy export"></p><p>相反，ES Modules 称之为 live binding，虽然 import 导入的数据是无法修改的，但是依旧会造成 import module 的对象的属性发生改变，会影响到 export module 里的对象。</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_04-768x316.png" alt="live binding"></p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>最后一步就是往内存空间中填充数据，JS 引擎会从顶层开始执行代码。</p><p><img src="https://hacks.mozilla.org/files/2018/03/40_top_level_code-768x224.png" alt="side effects"></p><p>上述代码导出的函数有潜在副作用（函数式编程的术语），所以模块的赋值操作只能进行一次。这就是引入 Module Map 的原因。因为每个模块都有唯一的 Module Record，保证了每个模块都只被执行一次，同样也是深度优先的方式执行。</p><p>和 CommonJS 不同，ES Modules 能够解决循环依赖的问题（cyclic dependency）：</p><p>首先是一个简单的例子</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/41_cyclic_graph.png" alt="usually"></p><p>看看 CommonJS 的逻辑：</p><p><img src="https://hacks.mozilla.org/files/2018/03/41_cjs_cycle-768x344.png" alt="step 0"></p><p>Counter 模块尝试获取 message 变量，但是 main 模块并没有执行完毕，所以得到 undefined。此时 JS 引擎为 Counter 中的 message 变量申请内存空间并设置为 undefined。</p><p><img src="https://hacks.mozilla.org/files/2018/03/43_cjs_cycle-768x344.png" alt="step 1"></p><p>当代码执行回到 main 模块中，message 变量会被初始化并添加到内存空间中，但是 Counter 模块无法感知。</p><p><img src="https://hacks.mozilla.org/files/2018/03/44_cjs_variable_2-768x331.png" alt="step 2"></p><p>如果是 ES Modules 的 live binding，counter 模块最终会看到正确的值，因为在 timeout 运行前，main 模块的赋值操作已经完成。这正是 ES Modules 包含三个阶段的设计带来的好处。</p><p>本文讲到这里也差不多结束了，以上所有内容主要是对<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener">《ES modules: A cartoon deep-dive》</a>这篇文章进行翻译后加上自己的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES Modules 使 JS 的模块系统标准化。这一标准化的工作差不多经历了 10 年。&lt;/p&gt;
&lt;p&gt;随着今年 5 月份 Firefox 60 的发布，所有的主流浏览器都将支持 ES Modules。此外 Node.js 团队当前也正在支持 ES Modules。代表 Web 未来的 WebAssembly 也正在集成 ES Modules。&lt;/p&gt;
&lt;p&gt;让我们先看看 ES Modules 解决了什么问题以及和其他模块系统的不同。&lt;br&gt;
    
    </summary>
    
    
      <category term="ES Modules" scheme="http://code.xnix.me/tags/ES-Modules/"/>
    
      <category term="翻译" scheme="http://code.xnix.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Rollup 初探</title>
    <link href="http://code.xnix.me/2018/05/02/Rollup-%E5%88%9D%E6%8E%A2/"/>
    <id>http://code.xnix.me/2018/05/02/Rollup-初探/</id>
    <published>2018-05-02T06:19:08.000Z</published>
    <updated>2018-05-02T07:50:47.673Z</updated>
    
    <content type="html"><![CDATA[<p>在传统软件开发的领域中，模块化开发将项目拆分成多个独立的模块便于维护。但是在过去 JS 因为历史原因而不具备这一核心功能。直到 ES6 带来了 ES Modules，但是这些并没有在浏览器和 Node.js 下实现。<br><a id="more"></a><br>可以将 Rollup 想像成 Babel，让你在编写代码的时候使用 ES Modules 这一特性，通过 Rollup 编译后降级为所支持的的格式代码（CommonJS，AMD modules 或者 IIFE 风格的脚本）。</p><p>Rollup 发布后，相比当时的 Webpack 一个最大的亮点就是 Tree-shaking（Webpack 后续也实现了这个功能）。</p><p>Rollup 会对 <code>import</code> 和 <code>export</code> 语句进行静态分析，只导入当前项目实际会运行的代码。这一也被称之为 <strong><em>live code inclusion</em></strong>。类似于 <strong><em>dead code elimination</em></strong>，但是更有效率（后者是消除无关代码）。大部分情况下 Tree-shaking 是个美丽的童话，因为在动态语言上进行静态分析是非常困难的，比如我们无法从对象上移除无用的方法。</p><p>那么 Rollup 是不是就一无是处了呢？Three-shaking 只是 Rollup 的一部分，相比 Webpack 会带来更多 modules 实现的相关代码，Rollup 会尽可能的保留原始代码，这一特点非常适合编写地方库。</p><p>在 JS 社区中，大量第三方库开始 Rollup，但是 Rollup 同样可以被用于大型应用。如果你想使用代码分割以及动态导入的功能，官方推荐使用 SystemJS。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在传统软件开发的领域中，模块化开发将项目拆分成多个独立的模块便于维护。但是在过去 JS 因为历史原因而不具备这一核心功能。直到 ES6 带来了 ES Modules，但是这些并没有在浏览器和 Node.js 下实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="Rollup" scheme="http://code.xnix.me/tags/Rollup/"/>
    
  </entry>
  
  <entry>
    <title>原型链理解</title>
    <link href="http://code.xnix.me/2018/04/28/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%90%86%E8%A7%A3/"/>
    <id>http://code.xnix.me/2018/04/28/原型链理解/</id>
    <published>2018-04-28T02:18:46.000Z</published>
    <updated>2018-04-28T02:40:50.303Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Person 函数的原型链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Object.prototype) &lt;- (Function.prototype) &lt;- Person.__proto__</span><br></pre></td></tr></table></figure><p>此时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">Person.__proto__.__proto === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line">Person.constructor === Person.__proto__.constructor <span class="comment">// true</span></span><br><span class="line">Person.constructor === <span class="built_in">Function</span>.prototype.constructor <span class="comment">// true</span></span><br><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>首先需要明确 JS 里一切皆以对象的形式表现。</p><p>对象的 <code>__proto__</code> 属性指向构造该对象的构造函数的原型，这保证了该对象能够访问在构造函数原型中定义的属性和方法。</p><p>Person 是一个函数也是一个对象（在 JS 里是 First Class），它的构造函数是 Function 函数，Function 的原型是 Function.prototype。所以 <code>Person.__proto__</code> 等于 <code>Function.prototype</code>。</p><p><code>prototype</code> 属性只有函数才有，prototype 是一个对象。prototype 有一个 <code>constructor</code> 属性，一般通过 new 关键字来进行调用，我们称之为构造函数。所以 <code>Person.prototype.constructor</code> 等于 <code>Person</code>。</p><p>Person 自身并没有 constructor 函数，需要通过 <code>__proto__</code> 来找到上一级原型的 constructor，即 <code>Function.prototype.constructor</code>。</p><p>上面并没有像其他编程语言一样提到<strong>类</strong>的概念，因为 JS 没有类的概念，一般通过函数来模拟类的行为。</p><p>理解了上面，下面这种情况也就很好理解了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><p>x 对象的原型链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Object.prototype) &lt;- (Person.prototype) &lt;- x.__proto__</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.__proto__ === Person.prototype</span><br><span class="line">x.__proto__.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>最后用一张图来收官：</p><p><img src="https://hybrid.xiaoying.tv/viva-spread/other/jsobj.jpg" alt="proto"></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原型链" scheme="http://code.xnix.me/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://code.xnix.me/2018/03/08/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://code.xnix.me/2018/03/08/函数式编程/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-04-26T07:59:02.764Z</updated>
    
    <content type="html"><![CDATA[<p>命令式（How to do） -&gt; 声明式（do What）<br><a id="more"></a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可缓存</li><li>可移植、自文档</li><li>可测试</li><li>透明性、等式推导</li><li>并行代码</li></ul><h2 id="常用工具函数实现"><a href="#常用工具函数实现" class="headerlink" title="常用工具函数实现"></a>常用工具函数实现</h2><p>curry</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="params">func</span> =&gt;</span> (...args0) =&gt; <span class="function">(<span class="params">...args1</span>) =&gt;</span> func(...args0, ...args1)</span><br></pre></td></tr></table></figure><p>compose - 参考 Redux</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">args</span> =&gt;</span> args</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trace 用于 debug compose</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = <span class="function"><span class="params">tag</span> =&gt;</span> x =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, x)</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Good-or-Bad"><a href="#Good-or-Bad" class="headerlink" title="Good or Bad"></a>Good or Bad</h2><p>Bad</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="function"><span class="params">name</span> =&gt;</span> hi(name)</span><br></pre></td></tr></table></figure><p>Good</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = name = <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> greeting = hi</span><br></pre></td></tr></table></figure><blockquote><p>Note: JS 中函数是 First Class</p></blockquote><p>Bad</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signUp = <span class="function"><span class="params">attrs</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = saveUser(attrs)</span><br><span class="line">  welcomeUser(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saveUser = <span class="function"><span class="params">attrs</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = Db.save(attrs)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> welcomeUser = <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  Email(user, ...)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signUp = <span class="function">(<span class="params">Db, Email, attrs</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = saveUser(Db, attrs)</span><br><span class="line">  welcomeUser(Email, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saveUser = <span class="function">(<span class="params">Db, attrs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> welcomeUser = <span class="function">(<span class="params">Email, user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 通过参数传递强制注入依赖，方便移植</p></blockquote><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>一切除计算结果之外发生的事情，从而导致函数变得不纯，可能包含但不限于：</p><ul><li>更改文件系统</li><li>往数据库插入数据</li><li>发送 HTTP 请求</li><li>可变数据</li><li>打印 log</li><li>获取用户输入</li><li>DOM 查询</li><li>访问系统状态</li></ul><p>我们需要做到的是让副作用在可控的范围内发生。</p><h3 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h3><p>只传递函数的一部分参数来调用它，让它返回一个函数来处理剩下的参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令式（How to do） -&amp;gt; 声明式（do What）&lt;br&gt;
    
    </summary>
    
    
      <category term="Functional paradigm" scheme="http://code.xnix.me/tags/Functional-paradigm/"/>
    
  </entry>
  
  <entry>
    <title>打造理想的前端团队</title>
    <link href="http://code.xnix.me/2018/01/15/%E6%89%93%E9%80%A0%E7%90%86%E6%83%B3%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F/"/>
    <id>http://code.xnix.me/2018/01/15/打造理想的前端团队/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-04-26T07:59:17.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全栈的心"><a href="#全栈的心" class="headerlink" title="全栈的心"></a>全栈的心</h2><a id="more"></a><p>前端的大方向最终是全栈，不应该仅仅局限于浏览器，所谓的全栈我认为是多接触其他领域，打破传统，从而能够更全面地思考前端。从某种意义上来说，全栈能力也是解决问题的能力，而不是无所不会的能力（这种能力几乎不会存在）。</p><p>所以对于整个团队而言，每个成员都应该抱有走向全栈的心态来服务前端。</p><p>全栈的同时，团队成员也需要有各自的个性，也就是专长。有人喜欢研究浏览器的兼容性，有人喜欢设计精美的界面和探索友好的交互，也有人喜欢玩点黑科技，这些我们都需要积极地鼓励。</p><h2 id="整体战斗力"><a href="#整体战斗力" class="headerlink" title="整体战斗力"></a>整体战斗力</h2><p>提高团队的整体战斗力，需要做到以下几点:</p><ul><li>统一代码风格</li><li>提高代码质量</li><li>周期性 code review 和技术分享</li></ul><p>在前端领域，做到统一的代码风格还是很简单的。借助 ESLint 定制代码风格，具体细节可以根据团队成员投票决定。一旦确定后，所有成员必须严格遵守。代码的目录结构也需要尽量做到统一，团队成员在阅读他人代码时，可以迅速定位到对应功能的代码，减少非技术性的干扰。对于团队新成员来说，也能够快速地上手。</p><p>提高代码质量，是时刻需要思考的问题。这一点需要每个成员在写代码前下意识地去思考，例如如何命名，何时写注释，采用何种设计模式等。当代码出现腐败味道（严重耦合、业务复杂难以控制等）的时候，就需要进行合适的重构。要有写单元测试习惯，提高代码的健壮性，对于将来他人接手重构，不会出现牵一发而动全身的局面。多写文档，很多时候自己的代码也可能在几个月后变得陌生，有一份详细的文档可以迅速帮助你回忆，同时对于他人来说也是了解相关代码的入口。</p><p>周期性的 code review 和技术分享，这一步做好是可以帮助团队成员共同进步，同时是形成团队文化的催化剂。既然是团队，就不能出现多个成员依次跳入同一个坑，浪费过多的时间成本和人力成本。周期性的 code review 可以让成员们了解彼此负责的代码，知道整个项目的痛点和亮点，对于优秀的代码可以学习运用到自己负责的领域，对于缺陷的代码可以反省自己，想想自己是否也遗留了这么一个坑。技术分享，对于自己可以巩固所掌握的知识，展现自己的能力；对于整个团队来说，能够提高整体水平和开发效率，并且掌握未来技术发展的风向标。</p><p>以上几点，需要长期的积累和总结，例如维护一份内部的前端开发规范手册、持续更新团队技术博客等，这样日积月累，很快就会明显看到技术沉淀，建立团队的技术壁垒。</p><h2 id="团队文化"><a href="#团队文化" class="headerlink" title="团队文化"></a>团队文化</h2><p>上面有提到过团队文化，团队文化和 Team Leader 关系重大。每个人都有自己的性格，在工作中需要照顾彼此的情绪，能够理解他人的难处。我能想到的方式就是 <strong>吃喝玩乐敲代码</strong>。程序员团体大部分是闷骚慢热型，工作之余一起插科打诨，可以减少很多压力，大家也能走得更近，也会有团队凝聚力。</p><h2 id="团队技术"><a href="#团队技术" class="headerlink" title="团队技术"></a>团队技术</h2><p>前端是直接面对用户的技术领域，用户最直观的感觉就是，美观的 UI 交互和稳定的服务。</p><p>主要可以从几个方面着手:</p><ul><li>UI 组件库和项目模板</li><li>高复用性基础服务</li><li>新技术探索尝试及落地</li></ul><p>搭建相关主题的 UI 组件库，界面风格统一，随着组件库逐渐完善，开发一个新页面的成本会越来越低，提高团队的开发效率。运营的小伙伴们也可以参照此组件库的设计主题，提供相关的设计界面，开发人员便可迅速产出结果。</p><p>很多项目的构建工具大部分逻辑是相同的，没必要每次都重复搭建一边。可以参照 <code>vue-cli</code> 等工具维护一套团队的 cli 工具，通过命令行模式生成相关的项目模板。减少业务需求开发的杂音。</p><p>对于高复用性基础服务，最重要的是稳定和复用。比如运营需要爬取 Youtube 视频，此处先进行业务和服务分离，获取 Youtube 的视频 ID 为业务逻辑，基础服务就是根据平台和相关 ID（或者其他唯一性标识）下载视频并上传到 OSS 上，返回视频的基本信息（缩略图、播放链接等）。如果后续运营突然想要爬取 Instagram 视频，写业务的同学就可以无须修改太多代码，直接向下游提供平台和视频 ID 等信息来获取视频的基本信息；写基础服务的同学也只需扩展相关平台的代码即可。随着基础服务的完善，相关业务需求只需关心业务本身，而无需关心底层技术的复杂性，使得完成业务需求变得高效。作为基础服务，处于业务代码的下一层，对于稳定性的要求也要更加严格。尽量保证较高的测试覆盖率，一些大改动也需要相关人员进行全面讨论后再做确定。</p><p>新技术有时候并不能带来太大的帮助，但是技术是在不断演化的。对于一些权重比较低的项目，可以将新技术应用其中快速得到反馈。如果团队成员一致认为能够对现有的项目带来帮助，可以考虑将新技术落地实践。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全栈的心&quot;&gt;&lt;a href=&quot;#全栈的心&quot; class=&quot;headerlink&quot; title=&quot;全栈的心&quot;&gt;&lt;/a&gt;全栈的心&lt;/h2&gt;
    
    </summary>
    
    
      <category term="team" scheme="http://code.xnix.me/tags/team/"/>
    
      <category term="front-end" scheme="http://code.xnix.me/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>React 文档笔记</title>
    <link href="http://code.xnix.me/2017/11/09/React-%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
    <id>http://code.xnix.me/2017/11/09/React-文档笔记/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2018-04-26T07:58:48.640Z</updated>
    
    <content type="html"><![CDATA[<p>重读了下 React 的文档，发现了很多过去被忽视的细节，所以写下这篇博客。<br><a id="more"></a></p><h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a><a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">Rendering Elements</a></h2><blockquote><p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p></blockquote><p>这里明确说明了 React 元素和 DOM 元素的区别，React 元素仅仅是个 plain object ，所以创建 React 元素消耗的资源非常低。因此维护一颗虚拟 DOM 树比真实 DOM 树廉价得多。</p><h2 id="Componets-and-Props"><a href="#Componets-and-Props" class="headerlink" title="Componets and Props"></a><a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">Componets and Props</a></h2><blockquote><p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p></blockquote><p>这里是一个概念的问题，只要能通过属性参数返回相应 React 元素的函数就是一个组件。这个函数一定是纯函数，也就是说外部参数一样，永远得到的是相同结果的组件。这也体现了 React 函数式编程的思想。</p><p>所以我们不应该在组件内修改属性，属性必须是只读形式，就像此章节最后提到的 <code>All React components must act like pure functions with respect to their props.</code></p><h2 id="State-and-Lifecycle"><a href="#State-and-Lifecycle" class="headerlink" title="State and Lifecycle"></a><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">State and Lifecycle</a></h2><blockquote><p>React may batch multiple setState() calls into a single update for performance.<br>Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.</p></blockquote><p>当多次调用 setState 方法时，React 会把多次调用方法合并成一个来提高性能。state 的更新可能是异步的，所以不能通过 this.state 来计算下一个 state 的值。这时需要向 setState 传一个回调函数，而不是一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="Handling-Events"><a href="#Handling-Events" class="headerlink" title="Handling Events"></a><a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="noopener">Handling Events</a></h2><p>三种绑定事件方法的方式：</p><p>通过 bind 方式，目前推荐做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// This binding is necessary to make `this` work in the callback</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p> 实验中的 public class fields 语法，官方做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This syntax ensures `this` is bound within handleClick.</span></span><br><span class="line">  <span class="comment">// Warning: this is *experimental* syntax.</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>或者使用箭头函数，因为每次作为属性传给子组件都是一个新的箭头函数，会造成子组件重渲染而带来小部分性能问题，谨慎使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// This syntax ensures `this` is bound within handleClick</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Conditional-Rendering"><a href="#Conditional-Rendering" class="headerlink" title="Conditional Rendering"></a><a href="https://reactjs.org/docs/conditional-rendering.html" target="_blank" rel="noopener">Conditional Rendering</a></h2><blockquote><p>Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance, componentWillUpdate and componentDidUpdate will still be called.</p></blockquote><p>我们可以返回 null 让 React 不渲染元素，但是该组件的生命周期方法仍然会被调用。</p><h2 id="Lists-and-Keys"><a href="#Lists-and-Keys" class="headerlink" title="Lists and Keys"></a><a href="https://reactjs.org/docs/lists-and-keys.html" target="_blank" rel="noopener">Lists and Keys</a></h2><blockquote><p>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings.</p></blockquote><p>需要注意的是 key 是 string 类型，且值是唯一的。</p><blockquote><p>Extracting Components with Keys</p></blockquote><p>对抽离的组件设置 key 属性，而不是在其组件内部的 render 方法中设置。（通常是在 map 函数中使用 key）</p><blockquote><p>Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name.</p></blockquote><p>key 是不会传给 React 组件，如果组件需要得到 key 的值，必须设置名称不为 key 的属性传给组件。</p><h2 id="Refs-and-the-DOM"><a href="#Refs-and-the-DOM" class="headerlink" title="Refs and the DOM"></a><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">Refs and the DOM</a></h2><blockquote><p>If the ref callback is defined as an inline function, it will get called twice during updates, first with null and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the ref callback as a bound method on the class, but note that it shouldn’t matter in most cases.</p></blockquote><p>ref 的回调发生在 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 之前。如果 ref 的回调是内联函数，在每次状态更新的时候，会被调用两次，第一次会得到 null 第二次得到 DOM 元素。因为每次 render 的时候，内联函数的内存地址都是不一样的（尽管内部逻辑是一样的），React 会调用一次老的回调，再调用一次新的。如果要避免这种情况，需要保持函数的地址是一致的。</p><h2 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a><a href="https://reactjs.org/docs/portals.html" target="_blank" rel="noopener">Portals</a></h2><p>v16 之前的两个隐藏 API 可以实现类似传送门的效果。</p><ul><li>unstable_renderSubtreeIntoContainer</li><li>unmountComponentAtNode</li></ul><p>但是通过 Portal 相比上面的两个 API 有一个优点：</p><blockquote><p>An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree.</p></blockquote><p>在传送门的入口组件触发事件，该事件会通过 React 组件树传送给父组件，即使在 DOM 树中父组件生成的 DOM 节点不是入口组件生成的 DOM 节点的父节点。</p><h2 id="Error-Boundaries"><a href="#Error-Boundaries" class="headerlink" title="Error Boundaries"></a><a href="https://reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">Error Boundaries</a></h2><blockquote><p>Error boundaries do not catch errors for:</p><ol><li>Event handlers</li><li>Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)</li><li>Server side rendering</li><li>Errors thrown in the error boundary itself (rather than its children)</li></ol></blockquote><p>事件回调，异步方法，服务端渲染，错误边界自身的错误，这几种情况无法被捕获。</p><blockquote><p>As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.</p></blockquote><p>从 v16 开始，错误发生而未捕获会造成卸载整个 React 组件树。官方解释，根据经验判断，一个发生错误的 UI 组件，更好的选择是移除它，而不是保留在树中。</p><h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a><a href="https://reactjs.org/docs/web-components.html" target="_blank" rel="noopener">Web Components</a></h2><blockquote><p>React and Web Components are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data.</p></blockquote><p>Web Component 提供强封装来解决组件重用的问题。React 提供声明式的编程方式来保持 DOM 和数据的同步。两者可以相辅相成。</p><p>在 React 中使用 Web Component，用 <strong>class</strong> 来代替 <strong>classNanme</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BrickFlipbox</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;brick-flipbox <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">      &lt;div&gt;front&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;back&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/brick-flipbox&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Higher-Order-Components"><a href="#Higher-Order-Components" class="headerlink" title="Higher-Order Components"></a><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">Higher-Order Components</a></h2><p>使用 displayName 更好地 Debug：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithSubscription</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要在 render 方法中使用高阶组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// A new version of EnhancedComponent is created on every render</span></span><br><span class="line">  <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  <span class="comment">// That causes the entire subtree to unmount/remount each time!</span></span><br><span class="line">  <span class="keyword">return</span> &lt;EnhancedComponent /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是性能问题，重新装载组件会造成组件的状态和所有子组件状态的丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重读了下 React 的文档，发现了很多过去被忽视的细节，所以写下这篇博客。&lt;br&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://code.xnix.me/tags/React/"/>
    
      <category term="doc" scheme="http://code.xnix.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>重读 Redux 源码</title>
    <link href="http://code.xnix.me/2017/11/08/%E9%87%8D%E8%AF%BB-Redux-%E6%BA%90%E7%A0%81/"/>
    <id>http://code.xnix.me/2017/11/08/重读-Redux-源码/</id>
    <published>2017-11-07T16:00:00.000Z</published>
    <updated>2018-04-26T07:59:23.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><a id="more"></a><p>私有变量</p><ul><li>currentReducer 当前的 reducer，用于生成状态树</li><li>currentState 当前状态树</li><li>currentListeners 当前的监听器方法数组</li><li>nextListeners 下一个待执行的监听器方法数组</li><li>isDispatching 在 dispatch 方法中，currentReducer 执行前后的状态。</li></ul><p>私有方法</p><p><code>ensureCanMutateNextListeners</code> 如果在监听器中调用了 dispatch，因为 dispatch 方法也会注意触发之前传入的监听器，为了在新的监听器被加入之前确保当前的监听器数组能够正常被调用，需要拷贝一份监听器。</p><p>共有方法</p><ul><li>getState 获取当前状态树。</li><li>subscribe 通过订阅来监听状态的变化，返回一个 unsubscribe 方法来取消监听。这里添加监听器之前会调用 ensureCanMutateNextListeners 方法。unsubscribe 在移除监听器前也会有同样的拷贝操作。</li><li>dispatch 发送 Action，来改变状态树，然后逐一调用 subscribe 传入的监听器方法。</li><li>replaceReducer 通过替换 reducer 从而生成新的状态树。通常在代码分隔和热加载机制中使用。</li><li>observable 为 observable/reactive 考虑的方法，这里不继续深入。</li></ul><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>合并多个子 reducer 返回一个总 reducer，通过这个返回的 reducer 方法可以得到 state 树。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">  <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">  <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">  <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  nextState[key] = nextStateForKey</span><br><span class="line">  hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure><h2 id="bindActionCreator"><a href="#bindActionCreator" class="headerlink" title="bindActionCreator"></a>bindActionCreator</h2><p>一个便捷方法，返回 Action Creator 方法封装 dispatch 后的对象，后续便可直接调用对象里的方法。一般使用场景，把 Action Creator 下传到子组件上，使子组件无法感知 Redux 的存在。</p><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>联合函数，将多个函数组装成管道传输值。compose(f, g, h) 将会转化为 (…args) =&gt; f(g(h(…args)))。</p><h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">let</span> chain = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch: (...args) =&gt; dispatch(...args)</code> 这段代码对 dispatch 用匿名函数包裹，因为后续 dispatch 会发生更新，使用闭包的好处在于匿名函数内部的 dispatch 会随之更新。</p><p><code>dispatch = compose(...chain)(store.dispatch)</code> 这段代码是最核心。假设 chain 数组为 [f, g, h]，最终会转化为 f(g(h(store.dispatch)))，从右到左执行返回一个新的 dispatch，形成从左向右顺序的调用链。</p><p>中间件格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [middleware name] = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// before</span></span><br><span class="line">  next(action)</span><br><span class="line">  <span class="comment">// after</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于链表，最后的 next 指向 store.dispatch，一个 action 的触发，先经过 middlewares 然后再调用 store.dispatch 改变 state。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;createStore&quot;&gt;&lt;a href=&quot;#createStore&quot; class=&quot;headerlink&quot; title=&quot;createStore&quot;&gt;&lt;/a&gt;createStore&lt;/h2&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://code.xnix.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Redux" scheme="http://code.xnix.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Docker 使用笔记</title>
    <link href="http://code.xnix.me/2017/04/01/Docker-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://code.xnix.me/2017/04/01/Docker-使用笔记/</id>
    <published>2017-03-31T16:00:00.000Z</published>
    <updated>2018-04-26T07:58:29.154Z</updated>
    
    <content type="html"><![CDATA[<p>安装好 docker 后，输入命令<br><a id="more"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看正在运行的 container，更多选项查看 <code>docker ps --help</code></p><h2 id="理解-image-和-container"><a href="#理解-image-和-container" class="headerlink" title="理解 image 和 container"></a>理解 image 和 container</h2><p>image 是静态的，由一个文件系统和一堆参数组成。当 image 被启动后，就被加载到 container。</p><p>当输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>Docker 会如下执行：</p><ul><li>检查本地是否存在 <code>hello-world</code> image</li><li>从 Docker Hub 上下载 image （或者其他 hub）</li><li>加载 image 到 container，并运行</li></ul><p>image 可能运行一个简单的命令然后退出，但也可以启动像数据库这般复杂的程序。使用 Docker，你完全不需要关心运行环境，container 会帮你解决这些问题。</p><h2 id="寻找并运行-image"><a href="#寻找并运行-image" class="headerlink" title="寻找并运行 image"></a>寻找并运行 image</h2><p>Docker 让我们可以创建并且分享 image。就像使用 GitHub 一样，你可以浏览 <a href="https://store.docker.com/community/images/docker/whalesay" target="_blank" rel="noopener">Docker Hub</a> 找到各种你想要的 image。</p><p>类似于上文的 hello world 事例，输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run docker/whalesay cowsay boo</span><br></pre></td></tr></table></figure><p>此时你就运行了一个 whalesay image，执行过程和 hello world 一样，只不过多了一些参数而已。</p><p>当你在 container 中运行 image，Docker 会先将 image 下载到本地，以后再执行此命令，会优先从本地读取。只有hub 上的 image 的发生改变，Docker 才会重新下载。</p><p>如果要查看本地已有的所有 image，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="构建-image"><a href="#构建-image" class="headerlink" title="构建 image"></a>构建 image</h2><p>首先要知道 <code>Dockerfile</code> 的概念，类似于 node 的 <code>package.json</code>，<code>Dockerfile</code> 是一个构建 image 的描述文件。</p><p>在项目目录下，创建一个 <code>Dockerfile</code> 文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FROM 关键字代表基于指定 image 改进，这里我们需要使用 whalesay image 的 cowsay 程序</span></span><br><span class="line"><span class="keyword">FROM</span> docker/whalesay:latest</span><br><span class="line"><span class="comment"># whalesay image 是基于 Ubuntu，所以我们使用 apt-get 来安装包，fortunes 程序会随机输出名人格言</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y update &amp;&amp; apt-get install -y fortunes</span></span><br><span class="line"><span class="bash"><span class="comment"># CMD 命令会在环境设置完毕后执行</span></span></span><br><span class="line"><span class="bash">CMD /usr/games/fortune -a | cowsay</span></span><br></pre></td></tr></table></figure><p>执行命令构建 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t docker-whale-test .</span><br></pre></td></tr></table></figure><p>-t 参数会给 image 打个标记，方便以后运行。不要忘记 <code>.</code> ，表示从当前目录寻找 <code>Dockerfile</code> 文件。</p><p>此时你就可以运行构建好的 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run docker-whale-test</span><br></pre></td></tr></table></figure><p>每次执行都会随机输出一条名言。</p><h2 id="Tag-push-pull-image"><a href="#Tag-push-pull-image" class="headerlink" title="Tag, push, pull image"></a>Tag, push, pull image</h2><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>可以看到 docker-whale-test 的 id</p><p>确保你有 Docker Hub 的账号，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag <span class="variable">$&#123;image id&#125;</span> <span class="variable">$&#123;hub accountname&#125;</span>/docker-whale-test:latest</span><br></pre></td></tr></table></figure><p>再次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>确保 docker-whale-test 已经被打上标签。</p><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>在 push image 到 Docker Hub 之前，你需要登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>在 Docker Hub 站点上创建一个同名仓库，然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push <span class="variable">$&#123;hub accountname&#125;</span>/docker-whale-test</span><br></pre></td></tr></table></figure><p>上传成功后，就可以到仓库首页查看具体信息了。</p><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>上传到 Docker Hub 后，你可以在任何地方通过 <code>docker pull</code> 获取 image。</p><p>首先你要删除本地的备份，否则 <code>docker pull</code> 会认为本地存在指定 image 而不去 Docker Hub 上获取 image。</p><p>通过以下命令删除本地指定 id 的 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f <span class="variable">$&#123;image id&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>docker image rm -f</code> 命令可以批量删除</p><p>最后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="variable">$&#123;hub accountname&#125;</span>/docker-whale-test</span><br></pre></td></tr></table></figure><p>就会自动下载并运行 image</p><h2 id="操作虚拟机"><a href="#操作虚拟机" class="headerlink" title="操作虚拟机"></a>操作虚拟机</h2><p>创建一个本地的虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox <span class="variable">$&#123;MACHINE-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>查看创建完的虚拟机的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine env <span class="variable">$&#123;MACHINE-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>创建完的虚拟机列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p>通过 ssh 访问创建好的虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh <span class="variable">$&#123;MACHINE-NAME&#125;</span></span><br></pre></td></tr></table></figure><h2 id="创建-swarm"><a href="#创建-swarm" class="headerlink" title="创建 swarm"></a>创建 swarm</h2><h3 id="初始化-swarm"><a href="#初始化-swarm" class="headerlink" title="初始化 swarm"></a>初始化 swarm</h3><p>ssh 登录到 manager 虚拟机，执行初始化 swarm 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-add <span class="variable">$&#123;MANAGER-IP&#125;</span></span><br></pre></td></tr></table></figure><h3 id="将-worker-添加到-swarm-中"><a href="#将-worker-添加到-swarm-中" class="headerlink" title="将 worker 添加到 swarm 中"></a>将 worker 添加到 swarm 中</h3><p>在上一步初始化完成后，会输出一个 <code>join</code> 命令。登录到 worker 虚拟机中执行这个命令，命令形式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join \</span><br><span class="line">--token SWMTKN-1-3msallxxbth84sgdvqblncb5915uxwsjv2pc1tsbs3vbv74oms-5xc8gf0cr3731mto8mjltt75x \</span><br><span class="line">192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>你也可以在 manager 虚拟机中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure><p>来重新获取 <code>join</code> 命令。</p><p>在 manager 虚拟机中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure><p>可以查看当前 swarm 中的节点。</p><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>创建一个 <code>docker-stack.yml</code> 文件，并复制到 manager 虚拟机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine scp docker-stack.yml manager:/home/docker/</span><br></pre></td></tr></table></figure><p>进入 manager 虚拟机中执行（之后修改 yml 文件，你也可以执行相同的命令进行重新部署）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy --compose-file docker-stack.yml <span class="variable">$&#123;APP-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>耐心等待创建完毕后，可以通过如下命令确认 stack 是否如期部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack services  <span class="variable">$&#123;APP-NAME&#125;</span></span><br></pre></td></tr></table></figure><h2 id="优雅地关闭，启动和清理应用"><a href="#优雅地关闭，启动和清理应用" class="headerlink" title="优雅地关闭，启动和清理应用"></a>优雅地关闭，启动和清理应用</h2><h3 id="暂停应用"><a href="#暂停应用" class="headerlink" title="暂停应用"></a>暂停应用</h3><p>从 worker 开始使用 <code>docker-machine stop</code> 命令来关闭虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine stop worker</span><br><span class="line">docker-machine stop manager</span><br></pre></td></tr></table></figure><h3 id="重启应用"><a href="#重启应用" class="headerlink" title="重启应用"></a>重启应用</h3><p>从 manager 开始使用 <code>docker-machine start</code> 命令来启动虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine start manager</span><br><span class="line">docker-machine start worker</span><br></pre></td></tr></table></figure><h3 id="移除应用"><a href="#移除应用" class="headerlink" title="移除应用"></a>移除应用</h3><p>登录 manager 虚拟机，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm <span class="variable">$&#123;APP-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>来删除应用以及 manager 和 worker 上相关的所有服务</p><p>通过 <code>docker stack ps ${APP-NAME}</code> 或者 <code>docker stack services ${APP-NAME}</code> 命令确定服务是否全部移除。</p><h3 id="移除虚拟机"><a href="#移除虚拟机" class="headerlink" title="移除虚拟机"></a>移除虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine rm -f worker</span><br><span class="line">docker-machine rm -f manager</span><br></pre></td></tr></table></figure><h2 id="通过默认的网络启动-container"><a href="#通过默认的网络启动-container" class="headerlink" title="通过默认的网络启动 container"></a>通过默认的网络启动 container</h2><p>安装完 Docker 后，自动会包含 3 个默认的网络，可以通过以下命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">66ed589ff017        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">5f904357860e        host                host                <span class="built_in">local</span></span><br><span class="line">e5e8d423a72e        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p><code>bridge</code> 是一个特殊的网络，没有额外的设置，Docker 会默认让 container 使用该网络。</p><p>我们启动一个 ubtuntu image，起一个额外的名字 <code>networktest</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=networktest ubuntu</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e05f4816b60b6e7e7841cef23905fc63d9e2a29f5755b25dac10dc0440a17e5d</span><br></pre></td></tr></table></figure><p>找到容器 IP 地址的一个简单方式就是通过网络监测命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"66ed589ff0170b57ad6fab27cf55d9355a70dad78bf0da9c14f05ec08941635c"</span>,</span><br><span class="line">        <span class="attr">"Created"</span>: <span class="string">"2017-04-01T01:23:09.546974394Z"</span>,</span><br><span class="line">        <span class="attr">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="attr">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="attr">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="attr">"Options"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span>,</span><br><span class="line">                    <span class="attr">"Gateway"</span>: <span class="string">"172.17.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Containers"</span>: &#123;</span><br><span class="line">            <span class="attr">"e05f4816b60b6e7e7841cef23905fc63d9e2a29f5755b25dac10dc0440a17e5d"</span>: &#123;</span><br><span class="line">                <span class="attr">"Name"</span>: <span class="string">"networktest"</span>,</span><br><span class="line">                <span class="attr">"EndpointID"</span>: <span class="string">"9f6bea72c3aca88aa11de0f98068f07fe5ca12d7f254c245745a6b1b09997ab8"</span>,</span><br><span class="line">                <span class="attr">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="attr">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="attr">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Options"</span>: &#123;</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>用以下命令从网络中来移除一个 container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect <span class="variable">$&#123;NETWORK-NAME&#125;</span> <span class="variable">$&#123;CONTAINER-ID | CONTAINER-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>如 <code>docker network disconnect bridge networktest</code></p><h2 id="自定义桥接网络"><a href="#自定义桥接网络" class="headerlink" title="自定义桥接网络"></a>自定义桥接网络</h2><p>Docker 原生支持桥接网络（bridge network）和覆盖网络（overlay network）。覆盖网络是更高级的主题，暂时不管。</p><p>创建一个桥接网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge-network</span><br></pre></td></tr></table></figure><p>-d 表示使用 bridge 驱动来创建新的网络。现在用命令 <code>docker netwrok ls</code> 查看下当前所有的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">66ed589ff017        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">5f904357860e        host                host                <span class="built_in">local</span></span><br><span class="line">11de3b834b42        my-bridge-network   bridge              <span class="built_in">local</span></span><br><span class="line">e5e8d423a72e        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>docker network inspect my-bridge-network</code> 命令，很多信息都是空的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"my-bridge-network"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"11de3b834b421ef9bc411867cf67b6f78207f7cdfa12ee83d23cd7c2b0e0ba89"</span>,</span><br><span class="line">        <span class="attr">"Created"</span>: <span class="string">"2017-04-05T02:08:27.299036035Z"</span>,</span><br><span class="line">        <span class="attr">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="attr">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="attr">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="attr">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"Subnet"</span>: <span class="string">"172.18.0.0/16"</span>,</span><br><span class="line">                    <span class="attr">"Gateway"</span>: <span class="string">"172.18.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Containers"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="将-container-添加到网络中"><a href="#将-container-添加到网络中" class="headerlink" title="将 container 添加到网络中"></a>将 container 添加到网络中</h2><p>container 可以在各自完全独立的网络中运行。</p><p>启动一个运行 PostgreSQL 数据库的 container，并连接到新的网络中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=my-bridge-network --name db training/postgres</span><br></pre></td></tr></table></figure><p>你可以使用 <code>docker network inspect</code> 命令来检测 container 是否加入到网络中。你也可以检测 container 被加入到哪个网络中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;json .NetworkSettings.Networks&#125;&#125;'</span> db</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"my-bridge-network"</span>:&#123;<span class="attr">"IPAMConfig"</span>:<span class="literal">null</span>,<span class="attr">"Links"</span>:<span class="literal">null</span>,<span class="attr">"Aliases"</span>:[<span class="string">"69527e528e38"</span>],<span class="attr">"NetworkID"</span>:<span class="string">"11de3b834b421ef9bc411867cf67b6f78207f7cdfa12ee83d23cd7c2b0e0ba89"</span>,<span class="attr">"EndpointID"</span>:<span class="string">"46d4c9d3f3d84ae9a08dee0a4aea52b42846f684a438e64d6801ea5d2dad51e9"</span>,<span class="attr">"Gateway"</span>:<span class="string">"172.18.0.1"</span>,<span class="attr">"IPAddress"</span>:<span class="string">"172.18.0.2"</span>,<span class="attr">"IPPrefixLen"</span>:<span class="number">16</span>,<span class="attr">"IPv6Gateway"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6Address"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6PrefixLen"</span>:<span class="number">0</span>,<span class="attr">"MacAddress"</span>:<span class="string">"02:42:ac:12:00:02"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们继续启动一个 web 应用，这次不特别指定某个网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web training/webapp python app.py</span><br></pre></td></tr></table></figure><p>检测到使用的是默认的 bridge 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;json .NetworkSettings.Networks&#125;&#125;'</span> web</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"bridge"</span>:&#123;<span class="attr">"IPAMConfig"</span>:<span class="literal">null</span>,<span class="attr">"Links"</span>:<span class="literal">null</span>,<span class="attr">"Aliases"</span>:<span class="literal">null</span>,<span class="attr">"NetworkID"</span>:<span class="string">"66ed589ff0170b57ad6fab27cf55d9355a70dad78bf0da9c14f05ec08941635c"</span>,<span class="attr">"EndpointID"</span>:<span class="string">"16de6cdfdd408b73a82cb222c3d380c71d6d201d3940ab4b2fc0391b33e4bb2d"</span>,<span class="attr">"Gateway"</span>:<span class="string">"172.17.0.1"</span>,<span class="attr">"IPAddress"</span>:<span class="string">"172.17.0.2"</span>,<span class="attr">"IPPrefixLen"</span>:<span class="number">16</span>,<span class="attr">"IPv6Gateway"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6Address"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6PrefixLen"</span>:<span class="number">0</span>,<span class="attr">"MacAddress"</span>:<span class="string">"02:42:ac:11:00:02"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>获取 web 的 IP 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> web</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure><p>使用 <code>docker exec</code> 来在指定的 container 中运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it db bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@69527e528e38:/<span class="comment"># ping 172.17.0.2</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 172.17.0.2 ping statistics ---</span><br><span class="line">9 packets transmitted, 0 received, 100% packet loss, time 8286ms</span><br><span class="line"></span><br><span class="line">root@69527e528e38:/<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><p>因为两个 container 运行在不同的网络中，所以是 ping 不通的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge-network web</span><br></pre></td></tr></table></figure><p>重新进入 db 执行 ping 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it db bash</span><br><span class="line">root@69527e528e38:/<span class="comment"># ping 172.18.0.3</span></span><br><span class="line">PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.159 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.110 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=3 ttl=64 time=0.109 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=4 ttl=64 time=0.109 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.18.0.3 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3127ms</span><br><span class="line">rtt min/avg/max/mdev = 0.109/0.121/0.159/0.025 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好 docker 后，输入命令&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://code.xnix.me/tags/docker/"/>
    
      <category term="note" scheme="http://code.xnix.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>关于 SlidePlus Hybrid 开发的一些总结</title>
    <link href="http://code.xnix.me/2016/09/12/%E5%85%B3%E4%BA%8E-SlidePlus-Hybrid-%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://code.xnix.me/2016/09/12/关于-SlidePlus-Hybrid-开发的一些总结/</id>
    <published>2016-09-11T16:00:00.000Z</published>
    <updated>2018-04-26T08:25:50.411Z</updated>
    
    <content type="html"><![CDATA[<p>本次总结包括以下几点：<br><a id="more"></a></p><ol><li>前端视频播放的兼容性问题</li><li>Hybrid 开发和调试环境的问题</li><li>Hybrid 的用户体验问题</li><li>Hyrbid 的优缺点</li></ol><h2 id="前端视频播放的兼容性问题"><a href="#前端视频播放的兼容性问题" class="headerlink" title="前端视频播放的兼容性问题"></a>前端视频播放的兼容性问题</h2><p>首先，iPhone 上播放视频方案，我们直接忽略掉 Flash，Safari Mobile 完全不支持。所以重点考虑 HTML5 的方式播放视频，好在 Safari 兼容 video 非常完美。<br>不过又带来另外一个问题，Safari 播放 HTML5 视频，系统会自动放大全屏，即便是使用了 inline 模式，依旧没有效果。<br>再说说 Android 平台上，从下图可以看到 Android 4.4 以上是完美支持 video 的，之前的版本可能存在兼容性，解决方案就是当不支持 HTML5 视频播放时，退一步采用 Flash 方案。但是这也带来另外一个工作量，就是需要完成两套视频播放器界面的 UI。</p><p><img src="https://ww1.sinaimg.cn/large/aa0fbcc4gw1f7r2gl7h8wj20dg0aggmb.jpg" alt="caniuse"></p><p>目前比较好的解决方案是采用 video.js 库，目前还在探索中。</p><h2 id="Hybrid-开发和调试环境的问题"><a href="#Hybrid-开发和调试环境的问题" class="headerlink" title="Hybrid 开发和调试环境的问题"></a>Hybrid 开发和调试环境的问题</h2><p>Native 和 HTML5 通讯主要通过我们搭建的 JSBridge 框架，调用方式主要通过类似如下的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSBridge.call(action, params, callback);</span><br></pre></td></tr></table></figure><p>上面 JSBridge 方式，HTML5 主动调用 Native 提供的接口，可以在 JSBridge 的基础上封装了一层 Promise 解决了回调地狱的问题，让接口调用的方式和前端使用 Fetch 请求网络接口的体验一样，将 Natvie 视为 Server。</p><p>当然我们还有一些业务是需要 Native 主动通知 HTML5 从而更新相关视图。这里 JSBridge 行不通了，我们采用消息发送的机制，Web 端添加监听器，Native 端发送事件以及事件参数。目前业务不太复杂的情况下，处理各类事件还是比较容易控制，接口之间的耦合度也很低。</p><p>在上述情况下，前端开发的体验和前后端分离的思想是类似的。</p><p>接下来说说调试体验，我们的前端是工程化，开发使用的是 ES6 语法，通过编译器转译成 ES5 语法，并通过压缩工具和打包工具，将 CSS 和 JS 导出为单页面应用。这里造成的一个问题就是线上调试异常困难。<br>所以我们一般采用本地调试，主要通过本地开启静态服务，手机通过局域网访问该站点进行调试工作。这样在很多情况下，是没有太大问题的。</p><p>但是由于 SlidePlus 是一款国际化的 App。需要挂载 VPN 模拟海外环境进行调试，这就不可能使用本地调试。目前还没有很好的解决方案，这也是遇到的一个坑。</p><h2 id="Hybrid-的用户体验问题"><a href="#Hybrid-的用户体验问题" class="headerlink" title="Hybrid 的用户体验问题"></a>Hybrid 的用户体验问题</h2><p>用户体验问题是 Hybrid 无法避免的问题，我们能做到的就是无限地去接近原生的体验。</p><p>请求页面的等待时间，这是最大的差异问题。<br>考虑在无网络和网络情况糟糕的情况下，不再请求服务器，而是使用本地预存好的静态页面。<br>为了保证网络访问情况在绝大部分情况下良好，国内采用阿里云的 CDN 加速，国外采用 Akamai CDN 加速。<br>为了减少请求流量，使用缓存和 ETag，基本优化方式和传统 Web 开发一致。<br>同时我们是单页面的概念，也就是说，第一次加载到网页后续的操作抛开请求接口的情况，基本都不需要请求网络，在一定程度上避免了频繁请求网络带来的延迟问题。<br>最后就是采用全站 https 方案解决运营商劫持的问题。（采用 https，在请求时会多了握手的链接，所以请求时间会略微变长）。还有一个 https 的坑，就是 Web 端请求 rpc 接口，收到的图片链接为 http 协议，这样会带来安全性问题，有些浏览器就会拒绝发出 http 请求，造成一些意外的问题。</p><p>浏览器视图渲染的等待时间，我们需要做到尽量少的操作 DOM，在不可避免的情况下，可以考虑合并多次操作 DOM 的行为，一次性操作。对于频繁操作 DOM 的地方，我们需要将行为缓存起来。<br>遇到无限滚动列表滑动，在 Android 会出现整屏空白的情况，这里我采用的是使用 <strong>* requestAnimationFrame</strong>* 一个提供了一个统一帧管理、提供监听帧的 API。该接口的好处，对于一个侦中对DOM的所有操作，只进行一次Layout和Paint；如果发生动画的元素被隐藏了，那么就不再去Paint。</p><p>在 Web 端，点击事件通常响应比原生慢很多，采用 fastclick 库可以非常好的避免这种问题。以及长按文本会弹出复制粘贴的菜单栏，这些我们都可以通过下面的 css 解决。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span>: <span class="selector-tag">none</span>;<span class="comment">/*禁用手机浏览器的用户选择功能 */</span></span><br><span class="line"><span class="selector-tag">-moz-user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h2 id="Hyrbid-的优缺点"><a href="#Hyrbid-的优缺点" class="headerlink" title="Hyrbid 的优缺点"></a>Hyrbid 的优缺点</h2><p>首先，至少在项目的初期，Hybrid 开发并没有 Native 开发那么快速，一堆无法预见的坑需要解决。</p><p>然后接口调试较以往比较困难，遇到一些问题都是在摸索中爬行，很多时候一个问题需要在 Web 端和 Native 端两边都排查一遍才能找到。</p><p>当然这些问题当 HTML5 容器逐渐成熟起来，把该爬到坑都爬过，后续 Native 端端开发会越来越轻松，一些业务代码可以迁移到 Web 端，在不发布新版本的情况下也可以很大自由地修改或增加一些需求，整个开发流程也会越来越灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次总结包括以下几点：&lt;br&gt;
    
    </summary>
    
    
      <category term="Hybrid" scheme="http://code.xnix.me/tags/Hybrid/"/>
    
      <category term="SlidePlus" scheme="http://code.xnix.me/tags/SlidePlus/"/>
    
  </entry>
  
  <entry>
    <title>剖析 Promise 内部机制</title>
    <link href="http://code.xnix.me/2016/07/21/%E5%89%96%E6%9E%90-Promise-%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://code.xnix.me/2016/07/21/剖析-Promise-内部机制/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2018-04-26T08:26:07.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从回调地狱说起-Callback-Hell"><a href="#从回调地狱说起-Callback-Hell" class="headerlink" title="从回调地狱说起 Callback Hell"></a>从回调地狱说起 Callback Hell</h2><a id="more"></a><p>在 Node 中，绝大部分操作都是异步的方式，例如读取一个文件内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./config/pass.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们通过传入一个回调函数作为异步完成的后续操作。</p><p>如果我们异步读取多个文件，等到所有文件读取完毕执行特定操作呢？<br>代码修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./config/pass.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  fs.readFile(<span class="string">'./config/pass1.txt'</span>, (err, data1) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    fs.readFile(<span class="string">'./config/pass2.txt'</span>, (err, data2) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">      fs.readFile(<span class="string">'./config/pass3.txt'</span>, (err, data3) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里还是简单地敲套三层，想象下业务突然复杂，一不小心嵌套五层以上，这画面太美。。。</p><h2 id="救世主-Promise"><a href="#救世主-Promise" class="headerlink" title="救世主 Promise"></a>救世主 Promise</h2><blockquote><p>Promise 的音译是普罗米修斯，是希腊神话故事中的英雄，名字的意思是“先知”。</p></blockquote><p>我们可以把上面 Node 读取文件的操作改造如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncReadFile</span> (<span class="params">filePath, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filePath, options, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看 Promise 是如何解决 Callback Hell 的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile(<span class="string">'./config/pass.text'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/pass1.text'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/pass2.text'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/pass3.text'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>对于先知的我们，故事的安排在脑中是即时出现的，而非实际上的异步发生。因此，作为创世的编程者而言，这种与瞬间思考所同步的代码更符合现实世界下的思考方式。因此，更易读更易于理解。</p></blockquote><p>Promise 是一种对异步操作的封装，在异步操作执行成功或者失败时执行指定方法。将横向的异步调用转换为纵向，因此更符合人类的思维方式。</p><p>一个 Promise 对象具备三种生命状态：pending、fulfilled 和 rejected。只能从最初的 pending 到 fulfilled 或者 rejected，而且状态的改变是不可逆的。</p><p><img src="https://ww3.sinaimg.cn/large/aa0fbcc4gw1f61u9ne8d1j208u04umxc.jpg" alt="pending"></p><p>我们先简单看下 Promise 的工作原理。</p><p><img src="https://ww4.sinaimg.cn/large/aa0fbcc4gw1f61u4fuaf0j20jc07b74z.jpg" alt="promise"></p><p>Promise 大致的工作流程是：</p><ul><li>创建 Promise 对象 =&gt; 进入等待处理阶段 Pending</li><li>处理完成后，切换到 Fulfilled 状态／ Rejected 状态</li><li>根据状态，执行 then 方法／执行 catch 方法 内的回调函数</li><li>then 方法返回新的 Promise，此时就支持链式调用</li></ul><p>这里创建一个 Promise 对象，Promise 内部维系着 resolve 和 reject 方法，resolve 会让 Promise 对象进入 Fulfilled 状态，并将 resolve 方法的第一个参数传给后续 then 所指定的 onFulfilled 函数。reject 方法同理，只不过是切换到 Rejected 状态，并将参数传给 catch 所指定的 onRejected 函数。</p><h2 id="一步步打造心中的-Promise"><a href="#一步步打造心中的-Promise" class="headerlink" title="一步步打造心中的 Promise"></a>一步步打造心中的 Promise</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>先抛开 rejected，实现一个 Promise 的调用链的简单代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferreds = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    deferreds.push(onFulfilled)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    deferreds.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">      deferred(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入理解上面代码逻辑：</p><ul><li>then 方法将 onFulfilled 函数压入 deferreds 队列中。</li><li>将 resolve 传给创建 Promise 时传入的函数，resolve 的作用是将 deferreds 中的 onFulfilled 函数队列逐一执行。</li></ul><p>但是这段代码暴露出一个严重的问题，如果 Promise 执行的是同步代码，resolve 是早于 then 方法的执行，这样造成一个问题：<strong>then 还没有及时把 onFulfilled 函数压入队列，此时 deferreds 还是空数组，resolve 执行后，后续注册到 deferreds 数组内的 onFulfilled 函数将不再执行。</strong></p><p>这里我们可以把 deferreds 数组视为水桶，onFulfilled 视为饮用水，resolve 视为开关。then 操作就是将饮用水一点点地注入到水桶中。想想我们还没将水加到水桶中（执行 then 操作）就打开开关（执行 resolve），这肯定是接不到水的。</p><p>解决的办法就是将 resolve 函数的执行改为异步。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>Promises/A+ 规范明确要求回调需要通过异步方式执行，保证一致可靠的执行顺序。通过 setTimeout 方法，我们可以轻松实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    pending.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">      deferred(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以把 resolve 执行放到下一个时钟周期。</p><h3 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h3><p>按照 Promise 规范，我们需要引入三种互斥的状态：pending、fulfilled、rejected。</p><p><img src="https://ww3.sinaimg.cn/large/aa0fbcc4gw1f61u9ne8d1j208u04umxc.jpg" alt="status"></p><p>执行 resolve 会将 pending 状态切换到 fulfilled，在此之后添加到 then 到函数都会立即被调用。</p><p>现在我们的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deferreds = []</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferreds.push(onFulfilled)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    onFulfilled(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">_value</span>) </span>&#123;</span><br><span class="line">    state = <span class="string">'fulfilled'</span></span><br><span class="line">    value = _value</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      deferreds.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">        deferred(value)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的基础，我们可以简单地调用 Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile(<span class="string">'./README.md'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了串行 Promise，我们在 then 中返回 this，并设置一个 value 来保存传给 resolve 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile(<span class="string">'./README.md'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./package.json'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>像上面这样调用，虽然可以通过，但是两次输出的 data 是相同的值，并不是真正意义上的链式调用。</p><h3 id="串行-Promise"><a href="#串行-Promise" class="headerlink" title="串行 Promise"></a>串行 Promise</h3><p>只要 then 方法每次调用都返回一个 Promise 对象，前一个 Promise 对象持有后一个 Promise 对象的 resolve 方法，这样串行就变得非常简单了。</p><p>这里需要对 then 方法进行改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    handle(&#123; onFulfilled, resolve &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    deferreds.push(deferred)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ret = deferred.onFulfilled(value)</span><br><span class="line">  deferred.resolve(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完成的主要任务是：</p><ul><li>then 方法中返回一个新的 Promise 对象，这样每次执行 then 方法，都返回一个 Promise 对象，让链式调用成为可能。</li><li>新创建的 Promise 对象调用上一级 Promise 的 handle 方法，传递自身的 resolve 方法和当前的 onFulfilled 函数。</li></ul><p>handle 相比之前的 then 多了一行 <code>deferred.resolve(ret)</code>，这一步是链式调用的关键点。此刻的 resolve 是下一级 Promise 的方法，上一级 Promise 执行这段方法调用，就开启了链式调用。</p><p>我们继续重构前面的 Promise 代码，这里主要修改的是 resolve 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deferreds = []</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then 方法永远会返回一个 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// handle 为上一级 Promise 的方法</span></span><br><span class="line">      handle(&#123; onFulfilled, resolve &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// then 方法将 deferred 传入时，先压入到 deferreds 中</span></span><br><span class="line">      deferreds.push(deferred)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 Bridge Promise 前一个 Promise 对象的 then 方法的 onFulfilled 函数</span></span><br><span class="line">    <span class="keyword">const</span> ret = deferred.onFulfilled(value)</span><br><span class="line">    <span class="comment">// resolve 执行 deferreds 中的 onFulfilled 方法，即下一个 Bridge Promise 的 then 中的回调函数</span></span><br><span class="line">    deferred.resolve(ret)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">_value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是 promise 对象</span></span><br><span class="line">    <span class="keyword">if</span> (_value &amp;&amp; (<span class="keyword">typeof</span> _value === <span class="string">'object'</span> || <span class="keyword">typeof</span> _value === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> then = _value.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 resolve 延迟到 promise 执行完毕后调用，切换 Bridge Promise 的状态。</span></span><br><span class="line">        then.call(_value, resolve)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是其它值</span></span><br><span class="line">    state = <span class="string">'fulfilled'</span></span><br><span class="line">    value = _value</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      deferreds.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">        handle(deferred)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-具体流程"><a href="#Promise-具体流程" class="headerlink" title="Promise 具体流程"></a>Promise 具体流程</h2><ol><li>实例化一个最初的 Promise 对象，设置最初的状态为 <code>pending</code>。</li><li>通过 then 方法，创建一个新的 Promise 对象，由于上一级 Promise 暂时处于 pending 状态，当前 then 方法的 onFulfilled 函数和新 Promise 的 resolve 方法放入到上一级 Promise 的 deferreds 数组中。</li><li>这样就形成这样一个画面：<strong>第一个 Promise 被实例化，调用 then 方法。then 会返回一个新的 Promise 对象，在上一个 then 方法的基础上继续通过新 Promise 的 then，形成一条调用链。<br>每一个被创建出来的新 Promise 的 resolve 都将传给上一级的 Promise 的 deferreds 数组来维护</strong></li><li>在第一个 Promise 对象的回调函数中执行异步操作，完成后调用 Promise 的 resolve 方法。</li><li>resolve 允许传入一个参数，该参数的值通过 Promise 内部的 value 变量维护。resolve 会把 Promise 的状态修改为 <code>fulfilled</code>，然后异步调用 handle 依次处理 deferreds 数组中的每一个 deferred。</li><li>此时第一个 Promise 的状态在上一步骤中被改为 fulfilled，于是 handle 主要完成的工作是，执行 deferred 的 onFulfilled 函数，并调用下一个 Promise 的 resolve 方法。</li><li>下一个 Promise 的 resovle 在上一级被执行成功后，同样会将状态切换到 <code>fulfilled</code> ，重复步骤 6 直到结束。</li></ol><p>这样 Promise 的核心逻辑，基本被我们实现了。至于 rejected 和 异常处理 就交给大家来思考吧（其实就是懒！）。</p><p>结束语：真的很难想象就这么几十行代码，竟然有如此强大的威力，理解 Promise 并不难，需要敬佩的是创造强大 Promise 魔法的第一批程序员。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从回调地狱说起-Callback-Hell&quot;&gt;&lt;a href=&quot;#从回调地狱说起-Callback-Hell&quot; class=&quot;headerlink&quot; title=&quot;从回调地狱说起 Callback Hell&quot;&gt;&lt;/a&gt;从回调地狱说起 Callback Hell&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Promise" scheme="http://code.xnix.me/tags/Promise/"/>
    
      <category term="源码" scheme="http://code.xnix.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hybrid App 优化笔记</title>
    <link href="http://code.xnix.me/2016/06/01/Hybrid-App-%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
    <id>http://code.xnix.me/2016/06/01/Hybrid-App-优化笔记/</id>
    <published>2016-05-31T16:00:00.000Z</published>
    <updated>2018-04-26T08:25:34.433Z</updated>
    
    <content type="html"><![CDATA[<p>混合型 App 优化的地方需要注意的细节有挺多地方，这里我把自己未来这一个月的工作感受都汇总到这里，方便大家参考。<br><a id="more"></a></p><h2 id="框架的选择"><a href="#框架的选择" class="headerlink" title="框架的选择"></a>框架的选择</h2><p>技术选型上，我对比了 Angular、React 和 Vue 三个框架。Angular 1.x 版本性能问题和大体积带来的流量问题第一个被我放弃掉，4月初我有学习过 Angular 2.0，相对于 1.x 版本有了很大的进步，但是考虑到依旧处于 Beta 版本，不敢冒险投入到生产环境中。</p><p>React 是个非常好的框架，可能是从 iOS 转过来的缘故吧，JSX 语法并没有那么反人类，而且在刚来小影的第一个项目就是用 React + Ant + Koa 这套技术栈基本完成了 Growth hacking 的数据报表页面的雏形。整个开发过程并没有遇到特别大的问题，基本上官方文档也写得足够详细。如果作为移动开发，React 是一个好的选择。但是就来说说这次为什么选择 Vue 的原因，首先 React 是通过重新修改 Vitural DOM ，然后和原生 DOM 进行 diff 比较，修改不同的节点这样一个工作原理。这里带来了一个问题就是直接操作原生 DOM 不是特别方便，虽然有 refs 和 findDOMNode 这些方式，但是写起来感觉还是不够优雅，而且这样就完全享受不到 Vitural DOM 带来的好处。第二个原因就是 React 是单向数据流，这样做看起来业务逻辑更加清晰，其实间接地带来另一个坑，就是不好管理各个组件的状态，而且组件之间的交互也变得困难。虽然 Flux 规范的框架一定程度上缓解了问题，但是同样带来了学习的成本。Redux 实现 FLux 规范，统一通过 state tree 来管理状态，每个行为触发一个 action，dispatch 分发 action 从而 reduce 出一个新的 state，state 一旦发生变化，就带来视图的重新渲染。上面这一套流程，对于刚接触 Redux 的童鞋来说，多少会有点懵逼。<br>最后说说我为什么选择 Vue，首先 Vue 是 MVVM 框架，双向绑定非常便捷，但是底层实现通过将普通 data 改造为 getter/setter 的属性的 data，然后通过一个 watcher 当做 DOM 和 Model 之间的媒介，从而达到一旦数据发生改变就通知视图重新渲染，视图上修改的数据同样反向通知 Model 进行同步修改。这样维护视图数据就变得非常轻松。然后一个原因就是 Vue 足够的轻量，而且性能突出。这两个特点简直太适合移动端的开发，流量是非常重要的一个因素，作为用户，谁也不希望打开一个页面需要加载好几MB的资源文件吧。和 App 合作的童鞋的要求就是一个页面尽量不要超过 200 kb。在流量方面后续还会有更多要讲，这里就点到为止。<strong>其实性能不是体现在 JS 的执行上，而是体现在 DOM 操作上.</strong>Vue 在 DOM 渲染上的优化工作实现起来非常简单，主要优化体现在标记重用组件等，官方文档有详细说明，这里不再赘述。总之，Vue 既有 Angular 的 MVVM 实现，也有指令、过滤器等特性，同时有像 React 的组件化开发体验，而且比 Angular 轻量灵敏、比 React 更方便操控 DOM。这就是我选择 Vue 的原因。</p><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>首先我们要知道 Hybrid App 的一套工作流程，Hybrid App 并非套壳浏览器这么简单。Native 层会构造出一个容器，用来呈现静态网页。这个容器内部有一个浏览器，一般内核为 Webkit。容器载入静态网页后，会注入一段 JS 脚本，通过这个脚本来实现 Native 和 JS 的交互。Native 这边预先设置原生 API 的接口，Web 层通过注册相应的事件，触发对应的回调函数。这样 JS 就能够完成像调用物理设备、唤起 Toast 等原生视图的效果。</p><p>Hybrid 最简单的实现就是每次 App 启动就请求静态服务器，获取静态 HTML5 页面。后期需要更新 App，只需更新这个静态页面就可以了。但是这里就带来了一个问题就是，每次用户都需要请求静态页面，如果页面没有更新就会造成流量浪费的情况。解决这个问题的方案就是使用缓存，图片资源尽量借助 Native 的二级缓存机制，加载图片依次从内存、磁盘上查找，依旧没有才继续发送网络请求，然后将请求到的图片缓存到内存和磁盘中，供下次查找，同时配合 LRU 替换算法提高缓存命中和空间优化。好在上面的实现方案很多第三方框架已经帮我们解决，iOS 平台例如 SDWebImage、YYImage 等都是非常好的轮子。</p><p>其他非图片的静态资源，比如 Vue 打包后的 js 以及 css 文件也大概有 200 kb 左右的资源，这里我们让它第一次请求后就缓存本地后，以后请求通过 etag 标签进行校验是否改动，没有修改则返回 304 然后从 cache 中读取，否则请求新的资源。etag 只需要服务器配置下，Native 端的 WebView 应该会自动实现此机制。这样可以将后续请求的流量从大概 200 kb 降到 1kb 不到。</p><p>下面是优化前后的对比情况：</p><p><img src="https://ww2.sinaimg.cn/large/aa0fbcc4gw1f4h6jzvyqcj20fs03pwf3.jpg" alt="before"></p><p><img src="https://ww2.sinaimg.cn/large/aa0fbcc4gw1f4h6l8b67jj20fs03qjry.jpg" alt="after"></p><p>可以看出加了 etag 后，不仅流量节省了，同时响应速度也快了不少。但是这里我们还需要注意到的情况就是即使这些静态资源没有被修改，但是我们还需要每次都请求网络来验证是否修改，虽然每次请求的数据量很小，但是还是可以继续优化。那就是适当地添加缓存过期时间，因为一般情况下我们不会每时每刻改变静态资源，这时候在添加 Cache-Control 或者 Expires ，让客户端在短时间内暂时从缓存中获取数据。</p><p>一些静态页面我们甚至不需要请求网络，只需要保存到本地，每次 WebView 启动都去本地目录下找到静态页面并渲染。这样基本可以做到秒开而且无流量消耗。至于更新本地的目录，只需要做到当 App 启动时，从服务器获取到校验码来校验是否改变从而选择是否更新即可。</p><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ul><li>不要忘记开启 GZip 压缩。</li><li>打包压缩 CSS 和 JS，减少请求次数。</li><li>开启 CDN 加速。</li><li>请求服务使用 IP 而非域名，去除 DNS 解析环节。</li><li>使用首屏加载。</li><li>按需加载资源。</li><li>如果有大量列表，使用滚屏加载。</li><li>减少 Cookie。</li><li>减少甚至不要重定向。</li><li>技术上尽量做到使用 WebP 格式的图片。</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>尽量少使用动画，毕竟所谓 Hybrid App 就是一个扬长避短的方案， Native 和 Web 各自发挥长处，相互弥补短处。Web 端不需要实现过多华丽的动画，这本身就是对性能的极大考验，即使要用也使用 CSS 动画，做到硬件加速。一些转场动画我们可以通过 JS 调用 Native 接口实现，不过依旧不太推荐过于丰富的动画效果。<br>资源加载方面，使用延迟加载，让屏幕之外的资源加载时间推移到首屏界面加载完毕后。对于加载时间过长的情况，使用进度条给用户一种期盼感，否则用户长时间面对无交互的屏幕会产生焦虑感从而关闭 App。<br>至于框架优化，在 Vue 里需要注意的地方就是列表重用即可。其它大部分优化 Vue 的作者已经做得很好，在某些方面是完全碾压 React 的。<a href="https://engineering.footballradar.com/from-a-react-point-of-vue-comparing-reactjs-to-vuejs-for-dynamic-tabular-data/" target="_blank" rel="noopener">可以参考两者的性能对比</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;混合型 App 优化的地方需要注意的细节有挺多地方，这里我把自己未来这一个月的工作感受都汇总到这里，方便大家参考。&lt;br&gt;
    
    </summary>
    
    
      <category term="Hybrid" scheme="http://code.xnix.me/tags/Hybrid/"/>
    
      <category term="优化" scheme="http://code.xnix.me/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
