<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Craft</title>
  
  <subtitle>Season&#39;s coding world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://code.xnix.me/"/>
  <updated>2018-05-16T03:24:33.610Z</updated>
  <id>http://code.xnix.me/</id>
  
  <author>
    <name>XueSeason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Generator 之旅</title>
    <link href="http://code.xnix.me/2018/05/15/Generator-%E4%B9%8B%E6%97%85/"/>
    <id>http://code.xnix.me/2018/05/15/Generator-之旅/</id>
    <published>2018-05-15T07:13:07.000Z</published>
    <updated>2018-05-16T03:24:33.610Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个 egg 的项目，用到了 ali-oss 这个库，发现是通过 generator 来解决异步。自从 Node v7.6.0 开始支持 async/await 特性，大部分场景都没有再接触 generator。突然对这个在 ES6 版本引入的语法变得陌生，决定好好总结下。<br><a id="more"></a></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>JS 中有四种表示集合的数据结构：Array，Object，Set，Map。用传统的面向对象思维考略问题，我们需要一个接口，来处理不同的数据接口。</p><p>迭代器（Iterator）就是一个完成遍历操作的接口。主要被 ES6 的 <strong>for…of</strong> 语句使用，该循环语句会调用对象的迭代器接口的实现方法。实现迭代器接口的对象，我们称之为可迭代（iterable）。</p><p>迭代器接口定义了返回值为 <strong>迭代器对象</strong> 的方法。迭代器对象存在一个 next 方法，当这个方法被调用时需要返回形如:<code>{value:1,done:false}</code>的结果。value 代表值，done 代表遍历是否结束。</p><p>上面提到的 Array，Set 和 Map默认实现了迭代器接口。我们通过<code>Symbol.iterator</code>属性来实现迭代器接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> it = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">it.next() <span class="comment">// &#123; value: 1,done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: 2,done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: 3,done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined,done: true &#125;</span></span><br></pre></td></tr></table></figure><p>除了 for…of 语句，还有以下调用迭代器方法的情况：</p><ol><li>解构赋值 const [a, b] = [1, 2]</li><li>扩展运算符 …[1, 2, 3]</li><li>yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口</li><li>Array.from</li><li>Promise.all 和 Promise.race</li></ol><p>迭代器对象除了一个必须实现的 next 方法，我可以有 return 和 throw 方法，return 会在 for…of 中触发 <strong>break</strong> 或者 <strong>continue</strong>时调用，通常用于清理释放资源。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>调用 Generator 会返回一个迭代器对象，该对象维护 Generator 函数内部的状态。可以将 Generator 理解为生成一些列的值（虽然这些值是通过惰性求值得到的），然后通过返回的迭代器对象进行遍历。而 yield 用于标记每次 调用 next 完成后的暂停点。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。这个机制可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>Generator 本质上就是一个迭代器生成函数，所以可以直接赋值给对象的 <strong>Symbol.iterator</strong> 属性。Generator 返回的迭代器实现了 throw 方法，可以在函数体外抛出的错误，先被 Generator 函数体内捕获。同时也实现了 return 方法，可以终结整个迭代器。</p><h3 id="next、throw-和-return-三者共同点"><a href="#next、throw-和-return-三者共同点" class="headerlink" title="next、throw 和 return 三者共同点"></a>next、throw 和 return 三者共同点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br><span class="line"></span><br><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error('出错了'));</span></span><br><span class="line"></span><br><span class="line">gen.return(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span> (<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1</span><br><span class="line">  <span class="keyword">yield</span>* iter2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span> (<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何数据结构只要有 Iterator 接口，就可以被yield*遍历。</p><p>yield* 命令可以很方便地取出嵌套数组的所有成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span> (<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(tree[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [ <span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> iterTree(tree)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h3><p>协程和线程很相似，都有自己的执行上下文、可以共享全局变量。但是同一时间可以有多个线程处于运行状态，而运行的协程只能有一个，其他协程都处于暂停状态。此外，线程是抢先式的，协程是合作式的，执行权由协程自己分配。</p><p>Generator 函数是 ES6 对协程的实现。Generator 执行的上下文遇到 yield 会暂时退出堆栈，等到执行 next 时，这个上下文会重新加入调用栈，继续恢复之前的状态。</p><h3 id="CO"><a href="#CO" class="headerlink" title="CO"></a>CO</h3><p>这里我们就不得不看看大神 TJ 的 co 库，可以看看它的源码，感受下 Generator 的强大。这里从早期的 1.0.0 版本入手。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">      args.push(done)</span><br><span class="line">      fn.apply(ctx || <span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该工具方法其实是一个<a href="/2018/03/08/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/#Curry">柯里化</a>的过程，主要将接受回调的异步方法，封装成 thunk。</p><p>形式转换如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(path, encoding, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line">fs.readFile(path, encoding)(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面是是早期 co 的核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn()</span><br><span class="line">  <span class="keyword">var</span> done</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">return</span> done(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以看作 gen.next(res)</span></span><br><span class="line">        ret = gen.send(res)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">return</span> done(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line">    <span class="keyword">if</span> (ret.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (done) done(<span class="literal">null</span>, ret.value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// non-function</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ret.value !=== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'yielded a non-function'</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// thunk</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这是最核心的部分，相当于 fs.readFile(path, encoding)(next)</span></span><br><span class="line">      ret.value(next)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        next(e)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process.nextTick(next)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    done = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点：</p><ol><li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</li><li>Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。</li></ol><p>参考资料：</p><ul><li><a href="http://es6.ruanyifeng.com/#docs/generator#Generator-prototype-throw" target="_blank" rel="noopener">Generator 函数的语法</a></li><li><a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个 egg 的项目，用到了 ali-oss 这个库，发现是通过 generator 来解决异步。自从 Node v7.6.0 开始支持 async/await 特性，大部分场景都没有再接触 generator。突然对这个在 ES6 版本引入的语法变得陌生，决定好好总结下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Generator" scheme="http://code.xnix.me/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>简单解释器构造 - Part.2</title>
    <link href="http://code.xnix.me/2018/05/07/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0-Part-2/"/>
    <id>http://code.xnix.me/2018/05/07/简单解释器构造-Part-2/</id>
    <published>2018-05-07T07:16:33.000Z</published>
    <updated>2018-05-07T08:12:50.108Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们可以让解释器稍微复杂点：<br><a id="more"></a></p><ol><li>允许多位数字输入</li><li>添加减法运算</li><li>允许空格字符的输入</li></ol><p>下面是新版本的解释器代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Token types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> INTEGER = <span class="string">'INTEGER'</span></span><br><span class="line"><span class="keyword">const</span> PLUS = <span class="string">'PLUS'</span></span><br><span class="line"><span class="keyword">const</span> MINUS = <span class="string">'MINUS'</span></span><br><span class="line"><span class="keyword">const</span> EOF = <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type, value) &#123;</span><br><span class="line">    <span class="comment">// token type: INTEGER, PLUS or EOF</span></span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="comment">// token value: 0, 1, 2, 3, 4, 8, 9, '+', or None</span></span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * String representation of the class instance.</span></span><br><span class="line"><span class="comment">   * Examples:</span></span><br><span class="line"><span class="comment">   *     Token(INTEGER, 3)</span></span><br><span class="line"><span class="comment">   *     Token(PLUS, +)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Token(<span class="subst">$&#123;<span class="keyword">this</span>.type&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.value&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (text) &#123;</span><br><span class="line">    <span class="comment">// client string input, e.g. "3+5", "12 - 5", etc</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">// this.pos is an index into this.text</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">    <span class="comment">// current token instance</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.currentChar = <span class="keyword">this</span>.text[<span class="keyword">this</span>.pos]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Advance the 'pos' pointer and set the 'current_char' variable.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  advance () &#123;</span><br><span class="line">    <span class="keyword">this</span>.pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &gt; <span class="keyword">this</span>.text.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentChar = <span class="literal">null</span> <span class="comment">// Indicates end of input</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentChar = <span class="keyword">this</span>.text[<span class="keyword">this</span>.pos]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  skipWhitespace () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.currentChar !== <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.currentChar === <span class="string">' '</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advance()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return a(multidigit) integer consumed from the input.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  integer () &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.currentChar !== <span class="literal">null</span> &amp;&amp; <span class="built_in">Number</span>.isInteger(+<span class="keyword">this</span>.currentChar)) &#123;</span><br><span class="line">      result += <span class="keyword">this</span>.currentChar</span><br><span class="line">      <span class="keyword">this</span>.advance()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> +result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="comment">   * This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="comment">   * apart into tokens. One part at a time.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getNextToken () &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.currentChar !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentChar === <span class="string">' '</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.skipWhitespace()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(+<span class="keyword">this</span>.currentChar)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Token(INTEGER, <span class="keyword">this</span>.integer())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentChar === <span class="string">'+'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advance()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.currentChar === <span class="string">'-'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advance()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Token(EOF, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat (tokenType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentToken.type === tokenType) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  expr () &#123;</span><br><span class="line">    <span class="comment">// set current token to the first token taken from the input</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// we expect the current token to be a '+' token</span></span><br><span class="line">    <span class="keyword">const</span> op = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">if</span> (op.type === PLUS) &#123;</span><br><span class="line">      <span class="keyword">this</span>.eat(PLUS)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.eat(MINUS)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// after the above call the this.currentToken is set to EOF token</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (op.type === PLUS) &#123;</span><br><span class="line">      result = left.value + right.value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = left.value - right.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">'13 - 1'</span></span><br><span class="line">  <span class="keyword">const</span> interpreter = <span class="keyword">new</span> Interpreter(text)</span><br><span class="line">  <span class="built_in">console</span>.log(interpreter.expr())</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引出一个术语，词义（lexeme）</p><p><img src="https://ruslanspivak.com/lsbasi-part2/lsbasi_part2_lexemes.png" alt="lexeme"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们可以让解释器稍微复杂点：&lt;br&gt;
    
    </summary>
    
    
      <category term="Interpreter" scheme="http://code.xnix.me/tags/Interpreter/"/>
    
  </entry>
  
  <entry>
    <title>简单解释器构造 - Part.1</title>
    <link href="http://code.xnix.me/2018/05/07/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%84%E9%80%A0-Part-1/"/>
    <id>http://code.xnix.me/2018/05/07/简单解释器构造-Part-1/</id>
    <published>2018-05-07T05:54:46.000Z</published>
    <updated>2018-05-07T07:15:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>无论你是新手还是经验丰富的开发者，如果你不知道编译器和解释器的工作原理，你也不会知道计算机是如何工作的。<br><a id="more"></a><br>为什么需要学习解释器和编译器？有三个原因：</p><ol><li>编写一个解释器或者编译器，需要学习并使用大量的技术。这能够帮助你提高技术从而变成一个更好的开发者。同时这些学到的技术，可以运用在其他开发领域。</li><li>你真的非常渴望了解计算机的工作原理。清楚解释器和编译器的构建过程，理解工作原理，让代码更可控。</li><li>你想自创一门编程语言或者 DSL。</li></ol><p>通常我们的程序是用高级语言编写的，计算机并不能理解高级语言，我们需要通过解释器或者编译将高级编程语言转为另一种形式，方便计算机理解。</p><p>将源程序转为机器语言进行处理（计算机可以直接理解的语言）的工具称之为编译器；直接处理高级语言（没有直接转化为机器语言）的工具称之为解释器。</p><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_compiler_interpreter.png" alt="compiler and interpreter"></p><p>下面是 Pascal 的阶乘函数例子：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> factorial;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n: interger)</span>:</span> longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        factorial := <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        factorial := n * factorial(n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n: interger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span> <span class="keyword">to</span> <span class="number">16</span> <span class="keyword">do</span></span><br><span class="line">        writeln(n, <span class="string">'! = '</span>, factorial(n));</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>先为解释器实现一个简单算数表达式，最简单的就是两个整数相加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Token types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> INTEGER = <span class="string">'INTEGER'</span></span><br><span class="line"><span class="keyword">const</span> PLUS = <span class="string">'PLUS'</span></span><br><span class="line"><span class="keyword">const</span> EOF = <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type, value) &#123;</span><br><span class="line">    <span class="comment">// token type: INTEGER, PLUS or EOF</span></span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="comment">// token value: 0, 1, 2, 3, 4, 8, 9, '+', or None</span></span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * String representation of the class instance.</span></span><br><span class="line"><span class="comment">   * Examples:</span></span><br><span class="line"><span class="comment">   *     Token(INTEGER, 3)</span></span><br><span class="line"><span class="comment">   *     Token(PLUS, +)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Token(<span class="subst">$&#123;<span class="keyword">this</span>.type&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.value&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (text) &#123;</span><br><span class="line">    <span class="comment">// client string input, e.g. "3+5"</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">// this.pos is an index into this.text</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">    <span class="comment">// current token instance</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="comment">   * This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="comment">   * apart into tokens. One part at a time.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getNextToken () &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">this</span>.text</span><br><span class="line">    <span class="comment">// is this.pos index past the end of the thsi.text?</span></span><br><span class="line">    <span class="comment">// if so, then return EOF token because there is no more</span></span><br><span class="line">    <span class="comment">// input left to convert into kokens</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &gt; text.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Token(EOF, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get a character at the position this.pos and decide</span></span><br><span class="line">    <span class="comment">// what token to create based on the single character</span></span><br><span class="line">    <span class="keyword">const</span> currentChar = text[<span class="keyword">this</span>.pos]</span><br><span class="line">    <span class="comment">// if the character is a digit then convert it to</span></span><br><span class="line">    <span class="comment">// integer, create an INTEGER token, increment this.pos</span></span><br><span class="line">    <span class="comment">// index to point to the next character after the digit</span></span><br><span class="line">    <span class="comment">// and return the INTEGER token</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(+currentChar)) &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">new</span> Token(INTEGER, +currentChar)</span><br><span class="line">      <span class="keyword">this</span>.pos += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentChar === <span class="string">'+'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">new</span> Token(PLUS, currentChar)</span><br><span class="line">      <span class="keyword">this</span>.pos += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat (tokenType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentToken.type === tokenType) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error pasring input'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  expr () &#123;</span><br><span class="line">    <span class="comment">// set current token to the first token taken from the input</span></span><br><span class="line">    <span class="keyword">this</span>.currentToken = <span class="keyword">this</span>.getNextToken()</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// we expect the current token to be a '+' token</span></span><br><span class="line">    <span class="keyword">const</span> op = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(PLUS)</span><br><span class="line">    <span class="comment">// we expect the current token to be a signle-digit integer.</span></span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">this</span>.currentToken</span><br><span class="line">    <span class="keyword">this</span>.eat(INTEGER)</span><br><span class="line">    <span class="comment">// after the above call the this.currentToken is set to EOF token</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = left.value + right.value</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">'3+5'</span></span><br><span class="line">  <span class="keyword">const</span> interpreter = <span class="keyword">new</span> Interpreter(text)</span><br><span class="line">  <span class="built_in">console</span>.log(interpreter.expr()) <span class="comment">// 2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码需要遵守三条规则：</p><ol><li>只允许输入一位数字</li><li>只支持加法操作</li><li>不允许空格字符输入</li></ol><p>为了让解释器能够理解 <code>&quot;3+5&quot;</code>，需要将字符串分解成各组件，这些组件称为 <code>token</code>。Token 是一个对象，拥有 type 和 value 属性。</p><p>将输入的字符串分解成 token 的过程，称为词法分析（lexical analysis），简称 laxer。所以第一步解释器需要读取输入的字符，然后转为 token 流。</p><p>方法 <code>getNextToken</code> 是解释器的词法分析器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'3+5'</span></span><br><span class="line"><span class="keyword">const</span> interpreter = <span class="keyword">new</span> Interpreter(text)</span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'INTEGER', value: 3 &#125;</span></span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'PLUS', value: '+' &#125;</span></span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'INTEGER', value: 5 &#125;</span></span><br><span class="line">interpreter.getNextToken() <span class="comment">// Token &#123; type: 'EOF', value: null &#125;</span></span><br></pre></td></tr></table></figure><p>方法 <code>expr</code> 确保 token 序列是正确的，如 INTEGER -&gt; PLUS -&gt; INTEGER，然后再进行加法运算。</p><p>以上差不多就是解释器里的 Hello World 例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论你是新手还是经验丰富的开发者，如果你不知道编译器和解释器的工作原理，你也不会知道计算机是如何工作的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interpreter" scheme="http://code.xnix.me/tags/Interpreter/"/>
    
  </entry>
  
  <entry>
    <title>深入 ES Modules（译）</title>
    <link href="http://code.xnix.me/2018/05/04/%E6%B7%B1%E5%85%A5-ES-Modules/"/>
    <id>http://code.xnix.me/2018/05/04/深入-ES-Modules/</id>
    <published>2018-05-04T08:42:19.000Z</published>
    <updated>2018-05-04T08:42:55.919Z</updated>
    
    <content type="html"><![CDATA[<p>ES Modules 使 JS 的模块系统标准化。这一标准化的工作差不多经历了 10 年。</p><p>随着今年 5 月份 Firefox 60 的发布，所有的主流浏览器都将支持 ES Modules。此外 Node.js 团队当前也正在支持 ES Modules。代表 Web 未来的 WebAssembly 也正在集成 ES Modules。</p><p>让我们先看看 ES Modules 解决了什么问题以及和其他模块系统的不同。<br><a id="more"></a></p><h2 id="最初的-JS"><a href="#最初的-JS" class="headerlink" title="最初的 JS"></a>最初的 JS</h2><p>最初 JS 只有函数作用域的概念，函数内部变量对外不可见。</p><p><img src="https://hacks.mozilla.org/files/2018/03/02_module_scope_01-768x448.png" alt="function scope"></p><p>但是不同函数作用域却无法共享变量。最简单的方式，把这个变量放到上一级作用域（比如全局作用域）。</p><p>例如 jQuery，当你需要使用 jQuery 的其他插件库时，必须确保 jQuery 在你的全局作用域里。</p><p><img src="https://hacks.mozilla.org/files/2018/03/02_module_scope_02-768x691.png" alt="global scope"></p><p>这样存在两个不足：</p><ul><li><p><strong>不明确的依赖关系</strong>。项目会变得难以维护，当修改历史代码时，加大整个项目崩溃的不确定性。</p></li><li><p><strong>造成全局变量污染</strong>。由于变量从全局作用域中获取，无法保证这个变量的正确性（可能被其他代码所修改）。</p></li></ul><h2 id="加入模块化后"><a href="#加入模块化后" class="headerlink" title="加入模块化后"></a>加入模块化后</h2><p>模块作用域让内部的变量可以被其他模块获取，其他模块可以明确指定获取哪些变量、类或者函数。</p><p><img src="https://hacks.mozilla.org/files/2018/03/02_module_scope_04-768x691.png" alt="module scope"></p><p>这样完美地解决了上面的两个不足。</p><p>在过去的模块化发展道路上，出现了大量模块化方案，当前 Node.js 所流行的 CommonJS 即将成为历史。ESM 作为新的模块化系统已经被加入了 JS 规范当中。浏览器已经支持了 ES Modules，Node.js 正在支持。</p><h2 id="ES-Modules-工作原理"><a href="#ES-Modules-工作原理" class="headerlink" title="ES Modules 工作原理"></a>ES Modules 工作原理</h2><p>通过 import 语句明确所需要加载的代码：</p><p><img src="https://hacks.mozilla.org/files/2018/03/04_import_graph-768x447.png" alt="dependencies"></p><p>浏览器会先解析文件，创建 Module Record：</p><p><img src="https://hacks.mozilla.org/files/2018/03/05_module_record-768x441.png" alt="Module Record"></p><p>随后 Module Record 需要被转成一个 Module Instance ，Module Instance 主要由<code>代码(code)</code>和<code>状态(state)</code>组成。</p><ul><li>code 是一系列指令，负责执行逻辑。</li><li>state 是指令所需要的计算机资源，通常是内存上保存的值。</li></ul><p>我们可以将 code 看做引擎，state 就是汽油。</p><p><img src="https://hacks.mozilla.org/files/2018/03/06_module_instance-768x572.png" alt="code state"></p><p>我们需要得到每一个 Module 的 Module Instance。整个 Module 的加载过程从一个入口文件开始构造一张完整的 Module Instance 依赖图。</p><p>对于 ES Modules 会进行以下三步骤：</p><ol><li>构造 - 获取文件，将文件解析为 Module Record。</li><li>实例化 - 从内存中申请一个空间（但是并没有进行赋值）。然后将 import 和 export 的变量的指针都指向这个空间地址。称之为链接（linking）。</li><li>赋值 - 运行代码，得到变量实际的值后填充到内存空间。</li></ol><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_3_phases.png" alt="three steps"></p><p>上述三个阶段可以独立执行，这让 ES Modules 能够实现异步加载。但是 ES Modules 也可以同步加载，这取决于加载方式。这里分成两种规格：</p><ul><li>ES module spec，规定了如何构造、实例化和赋值（上述三个步骤），但是并没有规定如何获取到文件。</li><li>Load module spec，不同规格规定了 loader 的加载方式，比如浏览器的 HTML spec。</li></ul><p><img src="https://hacks.mozilla.org/files/2018/03/07_loader_vs_es-768x439.png" alt="spec"></p><p>Loader 可以直接调用 ES Module 的方法 - <code>ParseModule</code>, <code>Module.Instantiate</code>, 和 <code>Module.Evaluate</code>，从而控制 ES Module 的整个实现过程。</p><p><img src="https://hacks.mozilla.org/files/2018/03/08_loader_as_puppeteer-768x507.png" alt="puppeteer"></p><p>下面是更详细的实现细节。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>构造阶段发生三件事：</p><ol><li>Module resolution，也就是获取文件的地址。</li><li>获取文件（通过 URL 下载、从文件系统加载）。</li><li>将文件解析为 Module Record。</li></ol><h3 id="查找并获取文件"><a href="#查找并获取文件" class="headerlink" title="查找并获取文件"></a>查找并获取文件</h3><p>首先从一个入口文件出发。在 HTML 中，通过一个 script 标签告诉 Loader 来查找相关文件。</p><p><img src="https://hacks.mozilla.org/files/2018/03/08_script_entry-768x288.png" alt="entry"></p><p>然后通过代码里的 import 语句中的标识符（module specifier）告诉 Loader 下一个需要加载的 Module。</p><p><img src="https://hacks.mozilla.org/files/2018/03/09_module_specifier-768x161.png" alt="module specifier"></p><h4 id="Module-specifier"><a href="#Module-specifier" class="headerlink" title="Module specifier"></a>Module specifier</h4><p>每一个宿主环境（通常是浏览器和 Node）有各自的 <code>module resolution algorithm</code> 来解释模块标识符字符串。有些模块标识符可以在 Node 环境中工作但是在浏览器中还无法工作，<a href="https://github.com/domenic/package-name-maps" target="_blank" rel="noopener">不过也快了</a>。</p><p>目前浏览器只接受 URL 作为模块标识符，通过 URL 可以加载相关的模块文件。在解析文件前，是无法得知后续需要获取的模块文件；同时在获取到文件前，也无法解析该模块文件。所以浏览器并不会同时加载整个依赖图的所有模块文件。</p><p>也就是说必须先一层层地遍历依赖图，解析一个模块文件，然后得到相关依赖，再查找并加载这些依赖，如此循环。</p><p><img src="https://hacks.mozilla.org/files/2018/03/10_construction-768x464.png" alt="go through"></p><p>如果主线程需要等待每个模块文件的下载（耗时任务），其他任务就会在队列中堆积。</p><p><img src="https://hacks.mozilla.org/files/2018/03/11_latency-768x415.png" alt="long time task"></p><p>主线程被阻塞会让整个应用变得卡顿，这也就是为什么 ES Modules spec 将模块的装载工作分成三个阶段。浏览器便可以异步获取文件，在构造过程中解析文件，得到模块依赖图，然后进行后续的同步实例化工作。</p><p>这也是 ES Modules 和 CommonJS 最关键的不同点。</p><p>CommonJS 并不需要考虑异步，因为在 Node 中是通过文件系统来加载模块文件，这比网络请求要快得多。这就允许 Node 在加载这些文件的时候阻塞主线程。也就是说在返回一个 Module Instance 之前，Node 已经遍历了整个依赖树，同时也完成了实例化和赋值的操作。</p><p><img src="https://hacks.mozilla.org/files/2018/03/12_cjs_require-768x457.png" alt="CommonJS"></p><p>因为 Node 采用 CommonJS 规范，你的模块标识符可以是一个变量（这在 ES Modules 中是不允许的，只有声明和语句才被允许）。同时因为加载是同步过程，同时进行了实例化和赋值操作，得到的变量也能同时得到其值。</p><p>但是 ES Modules 是预先构造好整个依赖图，然后才有赋值操作。这就造成在模块标识符字符串中不能使用变量（此时还没有值）。</p><p><img src="https://hacks.mozilla.org/files/2018/03/13_static_import-768x225.png" alt="variables in module specifiers"></p><p>这一不足，可以通过<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">动态导入（dynamic import）</a>弥补，形如 <code>import(&#96;${path}/foo.js&#96;)</code></p><p>这相当于构造一张新的依赖图，后续处理过程也是独立的。</p><p><img src="https://hacks.mozilla.org/files/2018/03/14dynamic_import_graph-768x597.png" alt="dynamic import"></p><h4 id="共享-Module-Instance"><a href="#共享-Module-Instance" class="headerlink" title="共享 Module Instance"></a>共享 Module Instance</h4><p>Loader 会缓存创建好的 Module Instance，如此一来，当多个模块依赖于一个模块，只会进行一次加载模块文件的操作，这样减少了引擎的压力。</p><p>Loader 会通过 Module Map 来管理这些缓存。</p><p>当需要获取指定模块文件，先将这个 URL 标记为 <strong>fetching</strong> 状态，然后再发送请求并开始下一个获取操作。</p><p><img src="https://hacks.mozilla.org/files/2018/03/15_module_map-768x261.png" alt="fetching"></p><p>如果其他文件依赖了相同的模块文件，Loader 会先遍历 Module Map 里的 URL，当 URL 是 fetching 状态时，直接跳过并开始下一个获取操作。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>获取到文件后，需要将其解析为 Module Record。</p><p><img src="https://hacks.mozilla.org/files/2018/03/25_file_to_module_record-768x306.png" alt="parse"></p><p>Module Record 被创建后，会更新 Module Map。</p><p><img src="https://hacks.mozilla.org/files/2018/03/25_module_map-768x367.png" alt="Module Map"></p><p>ES Module 通过 <strong>parse goal</strong> 来决定解析方式。</p><p>浏览器通过 script 的 type 属性来确定使用解析方式，<code>type=&quot;module&quot;</code> 告诉浏览器以 Module 方式解析。</p><p><img src="https://hacks.mozilla.org/files/2018/03/26_parse_goal-768x477.png" alt="type module"></p><p>但是在 Node 环境中，通常使用 <code>.mjs</code> 扩展名，这一方式还在讨论中，并不是最终方案。</p><p>下一步就开始实例化 Module，并链接所有 Module Instance。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>实例化的过程就是申请内存空间并绑定地址的过程。</p><p>首先 JS 引擎会为 Module Record 创建各自的 Module Environment Record，然后申请内存空间，通过 Module Environment Record 将 Module Record 导出的字段和相关的内存空间绑定。导出的函数声明在这个阶段被初始化，这让后续的赋值操作变得简单。</p><p>模块依赖图中的各个模块通过深度优先算法实例化。</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_01-768x316.png" alt="wire up exports"></p><p>先进行 exports 的链接操作，然后再回到顶层开始 imports 的链接操作。相匹配的 export 和 import 都会指向同一个内存地址</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_02-768x316.png" alt="wire up imports"></p><p>CommonJS 不同于 ES Modules，它的 export 操作会进行拷贝导出。</p><p><img src="https://hacks.mozilla.org/files/2018/03/31_cjs_variable-768x174.png" alt="copy export"></p><p>相反，ES Modules 称之为 live binding，虽然 import 导入的数据是无法修改的，但是依旧会造成 import module 的对象的属性发生改变，会影响到 export module 里的对象。</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_04-768x316.png" alt="live binding"></p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>最后一步就是往内存空间中填充数据，JS 引擎会从顶层开始执行代码。</p><p><img src="https://hacks.mozilla.org/files/2018/03/40_top_level_code-768x224.png" alt="side effects"></p><p>上述代码导出的函数有潜在副作用（函数式编程的术语），所以模块的赋值操作只能进行一次。这就是引入 Module Map 的原因。因为每个模块都有唯一的 Module Record，保证了每个模块都只被执行一次，同样也是深度优先的方式执行。</p><p>和 CommonJS 不同，ES Modules 能够解决循环依赖的问题（cyclic dependency）：</p><p>首先是一个简单的例子</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/41_cyclic_graph.png" alt="usually"></p><p>看看 CommonJS 的逻辑：</p><p><img src="https://hacks.mozilla.org/files/2018/03/41_cjs_cycle-768x344.png" alt="step 0"></p><p>Counter 模块尝试获取 message 变量，但是 main 模块并没有执行完毕，所以得到 undefined。此时 JS 引擎为 Counter 中的 message 变量申请内存空间并设置为 undefined。</p><p><img src="https://hacks.mozilla.org/files/2018/03/43_cjs_cycle-768x344.png" alt="step 1"></p><p>当代码执行回到 main 模块中，message 变量会被初始化并添加到内存空间中，但是 Counter 模块无法感知。</p><p><img src="https://hacks.mozilla.org/files/2018/03/44_cjs_variable_2-768x331.png" alt="step 2"></p><p>如果是 ES Modules 的 live binding，counter 模块最终会看到正确的值，因为在 timeout 运行前，main 模块的赋值操作已经完成。这正是 ES Modules 包含三个阶段的设计带来的好处。</p><p>本文讲到这里也差不多结束了，以上所有内容主要是对<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener">《ES modules: A cartoon deep-dive》</a>这篇文章进行翻译后加上自己的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES Modules 使 JS 的模块系统标准化。这一标准化的工作差不多经历了 10 年。&lt;/p&gt;
&lt;p&gt;随着今年 5 月份 Firefox 60 的发布，所有的主流浏览器都将支持 ES Modules。此外 Node.js 团队当前也正在支持 ES Modules。代表 Web 未来的 WebAssembly 也正在集成 ES Modules。&lt;/p&gt;
&lt;p&gt;让我们先看看 ES Modules 解决了什么问题以及和其他模块系统的不同。&lt;br&gt;
    
    </summary>
    
    
      <category term="ES Modules" scheme="http://code.xnix.me/tags/ES-Modules/"/>
    
      <category term="翻译" scheme="http://code.xnix.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Rollup 初探</title>
    <link href="http://code.xnix.me/2018/05/02/Rollup-%E5%88%9D%E6%8E%A2/"/>
    <id>http://code.xnix.me/2018/05/02/Rollup-初探/</id>
    <published>2018-05-02T06:19:08.000Z</published>
    <updated>2018-05-02T07:50:47.673Z</updated>
    
    <content type="html"><![CDATA[<p>在传统软件开发的领域中，模块化开发将项目拆分成多个独立的模块便于维护。但是在过去 JS 因为历史原因而不具备这一核心功能。直到 ES6 带来了 ES Modules，但是这些并没有在浏览器和 Node.js 下实现。<br><a id="more"></a><br>可以将 Rollup 想像成 Babel，让你在编写代码的时候使用 ES Modules 这一特性，通过 Rollup 编译后降级为所支持的的格式代码（CommonJS，AMD modules 或者 IIFE 风格的脚本）。</p><p>Rollup 发布后，相比当时的 Webpack 一个最大的亮点就是 Tree-shaking（Webpack 后续也实现了这个功能）。</p><p>Rollup 会对 <code>import</code> 和 <code>export</code> 语句进行静态分析，只导入当前项目实际会运行的代码。这一也被称之为 <strong><em>live code inclusion</em></strong>。类似于 <strong><em>dead code elimination</em></strong>，但是更有效率（后者是消除无关代码）。大部分情况下 Tree-shaking 是个美丽的童话，因为在动态语言上进行静态分析是非常困难的，比如我们无法从对象上移除无用的方法。</p><p>那么 Rollup 是不是就一无是处了呢？Three-shaking 只是 Rollup 的一部分，相比 Webpack 会带来更多 modules 实现的相关代码，Rollup 会尽可能的保留原始代码，这一特点非常适合编写地方库。</p><p>在 JS 社区中，大量第三方库开始 Rollup，但是 Rollup 同样可以被用于大型应用。如果你想使用代码分割以及动态导入的功能，官方推荐使用 SystemJS。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在传统软件开发的领域中，模块化开发将项目拆分成多个独立的模块便于维护。但是在过去 JS 因为历史原因而不具备这一核心功能。直到 ES6 带来了 ES Modules，但是这些并没有在浏览器和 Node.js 下实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="Rollup" scheme="http://code.xnix.me/tags/Rollup/"/>
    
  </entry>
  
  <entry>
    <title>原型链理解</title>
    <link href="http://code.xnix.me/2018/04/28/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%90%86%E8%A7%A3/"/>
    <id>http://code.xnix.me/2018/04/28/原型链理解/</id>
    <published>2018-04-28T02:18:46.000Z</published>
    <updated>2018-04-28T02:40:50.303Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Person 函数的原型链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Object.prototype) &lt;- (Function.prototype) &lt;- Person.__proto__</span><br></pre></td></tr></table></figure><p>此时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">Person.__proto__.__proto === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line">Person.constructor === Person.__proto__.constructor <span class="comment">// true</span></span><br><span class="line">Person.constructor === <span class="built_in">Function</span>.prototype.constructor <span class="comment">// true</span></span><br><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>首先需要明确 JS 里一切皆以对象的形式表现。</p><p>对象的 <code>__proto__</code> 属性指向构造该对象的构造函数的原型，这保证了该对象能够访问在构造函数原型中定义的属性和方法。</p><p>Person 是一个函数也是一个对象（在 JS 里是 First Class），它的构造函数是 Function 函数，Function 的原型是 Function.prototype。所以 <code>Person.__proto__</code> 等于 <code>Function.prototype</code>。</p><p><code>prototype</code> 属性只有函数才有，prototype 是一个对象。prototype 有一个 <code>constructor</code> 属性，一般通过 new 关键字来进行调用，我们称之为构造函数。所以 <code>Person.prototype.constructor</code> 等于 <code>Person</code>。</p><p>Person 自身并没有 constructor 函数，需要通过 <code>__proto__</code> 来找到上一级原型的 constructor，即 <code>Function.prototype.constructor</code>。</p><p>上面并没有像其他编程语言一样提到<strong>类</strong>的概念，因为 JS 没有类的概念，一般通过函数来模拟类的行为。</p><p>理解了上面，下面这种情况也就很好理解了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><p>x 对象的原型链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Object.prototype) &lt;- (Person.prototype) &lt;- x.__proto__</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.__proto__ === Person.prototype</span><br><span class="line">x.__proto__.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>最后用一张图来收官：</p><p><img src="https://hybrid.xiaoying.tv/viva-spread/other/jsobj.jpg" alt="proto"></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原型链" scheme="http://code.xnix.me/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://code.xnix.me/2018/03/08/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://code.xnix.me/2018/03/08/函数式编程/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-04-26T07:59:02.764Z</updated>
    
    <content type="html"><![CDATA[<p>命令式（How to do） -&gt; 声明式（do What）<br><a id="more"></a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可缓存</li><li>可移植、自文档</li><li>可测试</li><li>透明性、等式推导</li><li>并行代码</li></ul><h2 id="常用工具函数实现"><a href="#常用工具函数实现" class="headerlink" title="常用工具函数实现"></a>常用工具函数实现</h2><p>curry</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="params">func</span> =&gt;</span> (...args0) =&gt; <span class="function">(<span class="params">...args1</span>) =&gt;</span> func(...args0, ...args1)</span><br></pre></td></tr></table></figure><p>compose - 参考 Redux</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">args</span> =&gt;</span> args</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trace 用于 debug compose</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = <span class="function"><span class="params">tag</span> =&gt;</span> x =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, x)</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Good-or-Bad"><a href="#Good-or-Bad" class="headerlink" title="Good or Bad"></a>Good or Bad</h2><p>Bad</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="function"><span class="params">name</span> =&gt;</span> hi(name)</span><br></pre></td></tr></table></figure><p>Good</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = name = <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> greeting = hi</span><br></pre></td></tr></table></figure><blockquote><p>Note: JS 中函数是 First Class</p></blockquote><p>Bad</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signUp = <span class="function"><span class="params">attrs</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = saveUser(attrs)</span><br><span class="line">  welcomeUser(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saveUser = <span class="function"><span class="params">attrs</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = Db.save(attrs)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> welcomeUser = <span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  Email(user, ...)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signUp = <span class="function">(<span class="params">Db, Email, attrs</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = saveUser(Db, attrs)</span><br><span class="line">  welcomeUser(Email, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saveUser = <span class="function">(<span class="params">Db, attrs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> welcomeUser = <span class="function">(<span class="params">Email, user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 通过参数传递强制注入依赖，方便移植</p></blockquote><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>一切除计算结果之外发生的事情，从而导致函数变得不纯，可能包含但不限于：</p><ul><li>更改文件系统</li><li>往数据库插入数据</li><li>发送 HTTP 请求</li><li>可变数据</li><li>打印 log</li><li>获取用户输入</li><li>DOM 查询</li><li>访问系统状态</li></ul><p>我们需要做到的是让副作用在可控的范围内发生。</p><h3 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h3><p>只传递函数的一部分参数来调用它，让它返回一个函数来处理剩下的参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令式（How to do） -&amp;gt; 声明式（do What）&lt;br&gt;
    
    </summary>
    
    
      <category term="Functional paradigm" scheme="http://code.xnix.me/tags/Functional-paradigm/"/>
    
  </entry>
  
  <entry>
    <title>打造理想的前端团队</title>
    <link href="http://code.xnix.me/2018/01/15/%E6%89%93%E9%80%A0%E7%90%86%E6%83%B3%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F/"/>
    <id>http://code.xnix.me/2018/01/15/打造理想的前端团队/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-04-26T07:59:17.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全栈的心"><a href="#全栈的心" class="headerlink" title="全栈的心"></a>全栈的心</h2><a id="more"></a><p>前端的大方向最终是全栈，不应该仅仅局限于浏览器，所谓的全栈我认为是多接触其他领域，打破传统，从而能够更全面地思考前端。从某种意义上来说，全栈能力也是解决问题的能力，而不是无所不会的能力（这种能力几乎不会存在）。</p><p>所以对于整个团队而言，每个成员都应该抱有走向全栈的心态来服务前端。</p><p>全栈的同时，团队成员也需要有各自的个性，也就是专长。有人喜欢研究浏览器的兼容性，有人喜欢设计精美的界面和探索友好的交互，也有人喜欢玩点黑科技，这些我们都需要积极地鼓励。</p><h2 id="整体战斗力"><a href="#整体战斗力" class="headerlink" title="整体战斗力"></a>整体战斗力</h2><p>提高团队的整体战斗力，需要做到以下几点:</p><ul><li>统一代码风格</li><li>提高代码质量</li><li>周期性 code review 和技术分享</li></ul><p>在前端领域，做到统一的代码风格还是很简单的。借助 ESLint 定制代码风格，具体细节可以根据团队成员投票决定。一旦确定后，所有成员必须严格遵守。代码的目录结构也需要尽量做到统一，团队成员在阅读他人代码时，可以迅速定位到对应功能的代码，减少非技术性的干扰。对于团队新成员来说，也能够快速地上手。</p><p>提高代码质量，是时刻需要思考的问题。这一点需要每个成员在写代码前下意识地去思考，例如如何命名，何时写注释，采用何种设计模式等。当代码出现腐败味道（严重耦合、业务复杂难以控制等）的时候，就需要进行合适的重构。要有写单元测试习惯，提高代码的健壮性，对于将来他人接手重构，不会出现牵一发而动全身的局面。多写文档，很多时候自己的代码也可能在几个月后变得陌生，有一份详细的文档可以迅速帮助你回忆，同时对于他人来说也是了解相关代码的入口。</p><p>周期性的 code review 和技术分享，这一步做好是可以帮助团队成员共同进步，同时是形成团队文化的催化剂。既然是团队，就不能出现多个成员依次跳入同一个坑，浪费过多的时间成本和人力成本。周期性的 code review 可以让成员们了解彼此负责的代码，知道整个项目的痛点和亮点，对于优秀的代码可以学习运用到自己负责的领域，对于缺陷的代码可以反省自己，想想自己是否也遗留了这么一个坑。技术分享，对于自己可以巩固所掌握的知识，展现自己的能力；对于整个团队来说，能够提高整体水平和开发效率，并且掌握未来技术发展的风向标。</p><p>以上几点，需要长期的积累和总结，例如维护一份内部的前端开发规范手册、持续更新团队技术博客等，这样日积月累，很快就会明显看到技术沉淀，建立团队的技术壁垒。</p><h2 id="团队文化"><a href="#团队文化" class="headerlink" title="团队文化"></a>团队文化</h2><p>上面有提到过团队文化，团队文化和 Team Leader 关系重大。每个人都有自己的性格，在工作中需要照顾彼此的情绪，能够理解他人的难处。我能想到的方式就是 <strong>吃喝玩乐敲代码</strong>。程序员团体大部分是闷骚慢热型，工作之余一起插科打诨，可以减少很多压力，大家也能走得更近，也会有团队凝聚力。</p><h2 id="团队技术"><a href="#团队技术" class="headerlink" title="团队技术"></a>团队技术</h2><p>前端是直接面对用户的技术领域，用户最直观的感觉就是，美观的 UI 交互和稳定的服务。</p><p>主要可以从几个方面着手:</p><ul><li>UI 组件库和项目模板</li><li>高复用性基础服务</li><li>新技术探索尝试及落地</li></ul><p>搭建相关主题的 UI 组件库，界面风格统一，随着组件库逐渐完善，开发一个新页面的成本会越来越低，提高团队的开发效率。运营的小伙伴们也可以参照此组件库的设计主题，提供相关的设计界面，开发人员便可迅速产出结果。</p><p>很多项目的构建工具大部分逻辑是相同的，没必要每次都重复搭建一边。可以参照 <code>vue-cli</code> 等工具维护一套团队的 cli 工具，通过命令行模式生成相关的项目模板。减少业务需求开发的杂音。</p><p>对于高复用性基础服务，最重要的是稳定和复用。比如运营需要爬取 Youtube 视频，此处先进行业务和服务分离，获取 Youtube 的视频 ID 为业务逻辑，基础服务就是根据平台和相关 ID（或者其他唯一性标识）下载视频并上传到 OSS 上，返回视频的基本信息（缩略图、播放链接等）。如果后续运营突然想要爬取 Instagram 视频，写业务的同学就可以无须修改太多代码，直接向下游提供平台和视频 ID 等信息来获取视频的基本信息；写基础服务的同学也只需扩展相关平台的代码即可。随着基础服务的完善，相关业务需求只需关心业务本身，而无需关心底层技术的复杂性，使得完成业务需求变得高效。作为基础服务，处于业务代码的下一层，对于稳定性的要求也要更加严格。尽量保证较高的测试覆盖率，一些大改动也需要相关人员进行全面讨论后再做确定。</p><p>新技术有时候并不能带来太大的帮助，但是技术是在不断演化的。对于一些权重比较低的项目，可以将新技术应用其中快速得到反馈。如果团队成员一致认为能够对现有的项目带来帮助，可以考虑将新技术落地实践。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全栈的心&quot;&gt;&lt;a href=&quot;#全栈的心&quot; class=&quot;headerlink&quot; title=&quot;全栈的心&quot;&gt;&lt;/a&gt;全栈的心&lt;/h2&gt;
    
    </summary>
    
    
      <category term="team" scheme="http://code.xnix.me/tags/team/"/>
    
      <category term="front-end" scheme="http://code.xnix.me/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>写在 2017 伊始</title>
    <link href="http://code.xnix.me/2017/12/29/%E5%86%99%E5%9C%A8-2017-%E4%BC%8A%E5%A7%8B/"/>
    <id>http://code.xnix.me/2017/12/29/写在-2017-伊始/</id>
    <published>2017-12-28T22:29:32.000Z</published>
    <updated>2018-05-21T06:01:52.362Z</updated>
    
    <content type="html"><![CDATA[<p>和往年不一样，没有在 2016 写一次总结。主要有两个原因，一个是昨天在苏州跨年，电脑没有带在身边；另一个原因是，翻看 2016 年的这几篇博客，发现几个大事件基本都有写到，也没要炒冷饭的必要了。2017 年的第一天，回到杭州，想来想去还是写点什么东西好。就当是对 2016 年的一些补充吧，所以就写点这一年没提到的一些感想。<br><a id="more"></a></p><h2 id="谈谈城市"><a href="#谈谈城市" class="headerlink" title="谈谈城市"></a>谈谈城市</h2><p>2016 年去了很多地方，有之前去过的和没去过的，去的地方多了，渐渐地越来越喜欢杭州。毕业前就准备两个理想城市作为未来三年的起点，一个是杭州，一个是魔都。不知道是否是命运的安排，第一个面试就是小影这家创业公司，面试完毕后的当天收到了 HR 的电话和 offer，当时脑子一热就把剩下的面试都推掉了，回到宁波直接向三江提出离职，第三天就来杭州报到。好在小影并没有让我失望，各方面都让我挺安心的。就这么一呆就呆了半年多，认识了很多有意思的人。杭州的互联网环境也是吸引我的一个点，参加了各种技术沙龙，可以感受国内最前沿的技术氛围。不过说实话，我已经对超过 20 人以上的技术分享会已经完全失去了兴趣，对于我个人来说，很难一下人认识太多人，人太多了交流成本也随之提高，而且往往商业化十分严重。如果以后有什么技术沙龙，我想我多半是拒绝的。当然这些是远远不能让你对一个城市产生好感，和绝大多数人一样，喜欢一个人才会喜欢一座城。如果提到杭州我最喜欢的地方，可能不是西湖西溪这些著名的景点，也不是世纪大道武林广场这些商业地区，更不是古镇民居这些人文情怀。我能想到最美好的地方，可能就是古荡古墩老和山这一片区域。是与你一起消磨时光的老和山，是送你回家的那条古墩路，是穿过天目山路和你相见的玉泉。可惜这些已经美得不再真实，我也不会再拥有了，却已经转换为另一种感情，让我深深地爱上杭州。不管未来会在哪里，我想我永远都不会忘记这里的每一个场景。现在想想，还能够在这里生活工作，还真是件挺幸福的事情。</p><h2 id="关于-2016-的自省"><a href="#关于-2016-的自省" class="headerlink" title="关于 2016 的自省"></a>关于 2016 的自省</h2><p>虽然做不到吾日三省吾身，但不间断地自省还是需要的。现在最大的缺点，就是太过于友善。认识我的人，都知道我基本不会和人撕逼，吵个架第二天就像没事人一样和好。这也造成了很难做到合理的拒绝。尤其是在工作中，有时候各种没必要的需求，我都是尽量接受。这往往造成一段时间内突然工作压力变大，却又吃力不讨好。希望在今年能够学会说 No。另一个缺点，已经感觉到是不治之症了，那就是拖延症。一旦拖延症犯了，能把一星期的工作压缩到最后两天完成，前三天连自己都不知道在干什么，每天都在做思想斗争。我想我的内心里还是抗拒工作的，并不是因为懒，有时候一些工作对你来说毫无挑战却浪费时间，就如同流水线上拧螺丝一般枯燥乏味，却又必须强迫自己去完成。我想新的一年内能做到的就是如何合理地安排自己的工作时间。</p><p>该补充的差不多能想到的就这两点，下面就是立 Flag 的时候。看了看去年的目标，基本上实现了一半，也符合预期。今年就少定几个目标，希望年底回顾的时候，可以全部完成了。</p><ul><li>Github 上能够有一个拿得出手的 JS 项目，star 数量超过 50</li><li>不再乱买数码设备，至少存下 6 万块面包钱</li><li>努力提高专业英语的阅读能力，单词量从 7500 提升到 9000</li><li>多去 GYM，从 120 斤长到 135 斤</li></ul><p>每一个目标不是模棱两可，有具体数字，愿未来的我不会辜负现在。</p><p>最后再记一件小事，一个人从苏州回杭州的高铁上，特别没有安全感的我，竟然能淡定地在上面睡了一个多小时且没睡过站。回家的路上，公交卡竟然刚好刷光回去，之前还一直担心钱不够。现在想想，第一天就这么坦然且幸运地度过，这一年必然不差，新的一年里，愿我爱的人和爱我的人能够被生活所善待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和往年不一样，没有在 2016 写一次总结。主要有两个原因，一个是昨天在苏州跨年，电脑没有带在身边；另一个原因是，翻看 2016 年的这几篇博客，发现几个大事件基本都有写到，也没要炒冷饭的必要了。2017 年的第一天，回到杭州，想来想去还是写点什么东西好。就当是对 2016 年的一些补充吧，所以就写点这一年没提到的一些感想。&lt;br&gt;
    
    </summary>
    
    
      <category term="回顾" scheme="http://code.xnix.me/tags/%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>2017 回顾</title>
    <link href="http://code.xnix.me/2017/12/29/2017-%E5%9B%9E%E9%A1%BE/"/>
    <id>http://code.xnix.me/2017/12/29/2017-回顾/</id>
    <published>2017-12-28T22:29:32.000Z</published>
    <updated>2018-05-21T06:03:32.150Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 2017 年最后一个工作日，相比以往最大的不同就是满满地工作了一年，心态也发生了很大的改变。最主要的原因还是进入社会这个大染缸，想进一步改变自己人生的风向开始变得更加困难。总的来说，这一年对自己的表现，我是不太满意的。<br><a id="more"></a><br>首先说说年初设定的几个小目标:</p><blockquote><p>Github 上能够有一个拿得出手的 JS 项目，star 数量超过 50。</p></blockquote><p>有一个项目获得了 43 个 star，但是还真拿不出手。主要还是没有好的想法，以及对自己拖延症的无奈。</p><blockquote><p>不再乱买数码设备，至少存下 6 万块面包钱。</p></blockquote><p>年中配了一台主机，换了 Filco 键盘，买了 AirPods 耳机，还有双十一的天猫精灵和年初 iPhone6 丢失后换了备用机 Nexus。不再乱买数码设备，这个真的好难，每次看到新东西还是忍不住想掏钱把玩一下。好在涨了一波工资，存下 6 万块这个目标勉强算是完成。</p><blockquote><p>努力提高专业英语的阅读能力，单词量从 7500 提升到 9000。</p></blockquote><p>这一年感觉是停滞的一年，离开学校后突然忘记了如何去学习。每天下班回来之后脑子也非常累，几乎没有任何心情学习英语。应该好好规划下自己的时间来面对 2018 年的每一天。</p><blockquote><p>多去 GYM，从 120 斤长到 135 斤。</p></blockquote><p>去健身房的频率基本都能维持在一周 1~2 次，最近年底去的次数少了很多，但是就是不长肉啊！这还得靠饮食和作息，程序员能抽空去健身房已经很不容易了。</p><p>综合上面，意识到这一年是非常失败的一年。感觉也不是当初有想法就去实践的人了。工作和睡眠占据了人生绝大部分时间后，剩下的时间却被用来玩游戏和看剧当中。以此日复一日，到了年底，才发现这一年过得碌碌无为。只能庆幸通过这次回顾，能发现自己过得竟然是如此不堪的生活。还是得多多自省下自己啊！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>今年比较大的收获大概是对计算机网络的理解深入了许多，也归功于上半年整天和爬虫以及网络加密等技术打交道。最近也学习了 Go 语言，到目前为止已经接触了很多 C 类语言，希望明年可以多接触其他类型的语言开阔下视野。</p><p>昨天赶在元旦前，趁年底工作之余，快速写了一个属于自己的博客系统。也就是现在看到的 X-nix 网站，目前功能还是很粗糙，而且本来就是作为自用，没有为社区贡献的打算，不过代码是开源的，但不接受任何 PR。剩下打算在 2018 年优化下 SEO 和博客界面。</p><p>明年主要还是前端为主，不过这个领域的权重应该会再降一个档次，观望着开阔下其他领域。因为我总有一种预感，基础前端很有可能在人工智能的发展下被淘汰。而且可能来的比想像中的早。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今年看的电影还是蛮多的，但是印象深刻的不多。现在能想起来耐人寻味的是一部童话剧《海蒂和爷爷》，很温馨的一部电影，引入豆瓣上的一句点评：<code>人至善，景至美，故事细腻，淳朴动人，人生本该如此，温情永存，何惧苦难？</code></p><p>至于读书，我发现这阅读从上了大学之后，就没真正地读过一本文学书。这或许可以添加到 2018 年的 todo list 中。如果有机会的话，希望可以从《三体》开始。</p><p>今年基本没有离开过杭州这个城市，除了回温州。所以没有太多留念的照片，这是我感到非常遗憾的一件事情。希望以后可以每年来一场说走就走的旅行。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>这一年的工作还算得上顺风顺水，工资如愿得涨了，奖金也是出乎意料的多了，但是真正在工作中体会到的乐趣开始递减了。大概原因，应该是技术增长开始变缓瓶颈期将近已经关系好的同事逐渐离职。剩下最主要的可能是工作开始慢慢侵蚀生活这块领域。所谓能力愈大责任愈大。</p><p>借用马云式说法就是，我最怀念的还是当初实习 200 块一天的日子，那时候任务不重日子滋润，想法也单一。</p><p>2018 年只会是越来越偏离个人理想，不过我已经尝试着习惯了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管这一年过得怎样，这一年终归是过去了，无须过多地妄自菲薄，向前看吧，All is well。</p><p>最后老规矩，罗列下 2018 年的 list：</p><ul><li>看一部文学书，比如《三体》。</li><li>继续存钱，希望能到 20 万。</li><li>来一次说走就走的长途旅行。</li><li>努力学习 CSS。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是 2017 年最后一个工作日，相比以往最大的不同就是满满地工作了一年，心态也发生了很大的改变。最主要的原因还是进入社会这个大染缸，想进一步改变自己人生的风向开始变得更加困难。总的来说，这一年对自己的表现，我是不太满意的。&lt;br&gt;
    
    </summary>
    
    
      <category term="回顾" scheme="http://code.xnix.me/tags/%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>React 文档笔记</title>
    <link href="http://code.xnix.me/2017/11/09/React-%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
    <id>http://code.xnix.me/2017/11/09/React-文档笔记/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2018-04-26T07:58:48.640Z</updated>
    
    <content type="html"><![CDATA[<p>重读了下 React 的文档，发现了很多过去被忽视的细节，所以写下这篇博客。<br><a id="more"></a></p><h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a><a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">Rendering Elements</a></h2><blockquote><p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p></blockquote><p>这里明确说明了 React 元素和 DOM 元素的区别，React 元素仅仅是个 plain object ，所以创建 React 元素消耗的资源非常低。因此维护一颗虚拟 DOM 树比真实 DOM 树廉价得多。</p><h2 id="Componets-and-Props"><a href="#Componets-and-Props" class="headerlink" title="Componets and Props"></a><a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">Componets and Props</a></h2><blockquote><p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p></blockquote><p>这里是一个概念的问题，只要能通过属性参数返回相应 React 元素的函数就是一个组件。这个函数一定是纯函数，也就是说外部参数一样，永远得到的是相同结果的组件。这也体现了 React 函数式编程的思想。</p><p>所以我们不应该在组件内修改属性，属性必须是只读形式，就像此章节最后提到的 <code>All React components must act like pure functions with respect to their props.</code></p><h2 id="State-and-Lifecycle"><a href="#State-and-Lifecycle" class="headerlink" title="State and Lifecycle"></a><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">State and Lifecycle</a></h2><blockquote><p>React may batch multiple setState() calls into a single update for performance.<br>Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.</p></blockquote><p>当多次调用 setState 方法时，React 会把多次调用方法合并成一个来提高性能。state 的更新可能是异步的，所以不能通过 this.state 来计算下一个 state 的值。这时需要向 setState 传一个回调函数，而不是一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h2 id="Handling-Events"><a href="#Handling-Events" class="headerlink" title="Handling Events"></a><a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="noopener">Handling Events</a></h2><p>三种绑定事件方法的方式：</p><p>通过 bind 方式，目前推荐做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// This binding is necessary to make `this` work in the callback</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p> 实验中的 public class fields 语法，官方做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This syntax ensures `this` is bound within handleClick.</span></span><br><span class="line">  <span class="comment">// Warning: this is *experimental* syntax.</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>或者使用箭头函数，因为每次作为属性传给子组件都是一个新的箭头函数，会造成子组件重渲染而带来小部分性能问题，谨慎使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// This syntax ensures `this` is bound within handleClick</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Conditional-Rendering"><a href="#Conditional-Rendering" class="headerlink" title="Conditional Rendering"></a><a href="https://reactjs.org/docs/conditional-rendering.html" target="_blank" rel="noopener">Conditional Rendering</a></h2><blockquote><p>Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance, componentWillUpdate and componentDidUpdate will still be called.</p></blockquote><p>我们可以返回 null 让 React 不渲染元素，但是该组件的生命周期方法仍然会被调用。</p><h2 id="Lists-and-Keys"><a href="#Lists-and-Keys" class="headerlink" title="Lists and Keys"></a><a href="https://reactjs.org/docs/lists-and-keys.html" target="_blank" rel="noopener">Lists and Keys</a></h2><blockquote><p>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings.</p></blockquote><p>需要注意的是 key 是 string 类型，且值是唯一的。</p><blockquote><p>Extracting Components with Keys</p></blockquote><p>对抽离的组件设置 key 属性，而不是在其组件内部的 render 方法中设置。（通常是在 map 函数中使用 key）</p><blockquote><p>Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name.</p></blockquote><p>key 是不会传给 React 组件，如果组件需要得到 key 的值，必须设置名称不为 key 的属性传给组件。</p><h2 id="Refs-and-the-DOM"><a href="#Refs-and-the-DOM" class="headerlink" title="Refs and the DOM"></a><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">Refs and the DOM</a></h2><blockquote><p>If the ref callback is defined as an inline function, it will get called twice during updates, first with null and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the ref callback as a bound method on the class, but note that it shouldn’t matter in most cases.</p></blockquote><p>ref 的回调发生在 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 之前。如果 ref 的回调是内联函数，在每次状态更新的时候，会被调用两次，第一次会得到 null 第二次得到 DOM 元素。因为每次 render 的时候，内联函数的内存地址都是不一样的（尽管内部逻辑是一样的），React 会调用一次老的回调，再调用一次新的。如果要避免这种情况，需要保持函数的地址是一致的。</p><h2 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a><a href="https://reactjs.org/docs/portals.html" target="_blank" rel="noopener">Portals</a></h2><p>v16 之前的两个隐藏 API 可以实现类似传送门的效果。</p><ul><li>unstable_renderSubtreeIntoContainer</li><li>unmountComponentAtNode</li></ul><p>但是通过 Portal 相比上面的两个 API 有一个优点：</p><blockquote><p>An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree.</p></blockquote><p>在传送门的入口组件触发事件，该事件会通过 React 组件树传送给父组件，即使在 DOM 树中父组件生成的 DOM 节点不是入口组件生成的 DOM 节点的父节点。</p><h2 id="Error-Boundaries"><a href="#Error-Boundaries" class="headerlink" title="Error Boundaries"></a><a href="https://reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">Error Boundaries</a></h2><blockquote><p>Error boundaries do not catch errors for:</p><ol><li>Event handlers</li><li>Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)</li><li>Server side rendering</li><li>Errors thrown in the error boundary itself (rather than its children)</li></ol></blockquote><p>事件回调，异步方法，服务端渲染，错误边界自身的错误，这几种情况无法被捕获。</p><blockquote><p>As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.</p></blockquote><p>从 v16 开始，错误发生而未捕获会造成卸载整个 React 组件树。官方解释，根据经验判断，一个发生错误的 UI 组件，更好的选择是移除它，而不是保留在树中。</p><h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a><a href="https://reactjs.org/docs/web-components.html" target="_blank" rel="noopener">Web Components</a></h2><blockquote><p>React and Web Components are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data.</p></blockquote><p>Web Component 提供强封装来解决组件重用的问题。React 提供声明式的编程方式来保持 DOM 和数据的同步。两者可以相辅相成。</p><p>在 React 中使用 Web Component，用 <strong>class</strong> 来代替 <strong>classNanme</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BrickFlipbox</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;brick-flipbox <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">      &lt;div&gt;front&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;back&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/brick-flipbox&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Higher-Order-Components"><a href="#Higher-Order-Components" class="headerlink" title="Higher-Order Components"></a><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">Higher-Order Components</a></h2><p>使用 displayName 更好地 Debug：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithSubscription</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要在 render 方法中使用高阶组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// A new version of EnhancedComponent is created on every render</span></span><br><span class="line">  <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  <span class="comment">// That causes the entire subtree to unmount/remount each time!</span></span><br><span class="line">  <span class="keyword">return</span> &lt;EnhancedComponent /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是性能问题，重新装载组件会造成组件的状态和所有子组件状态的丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重读了下 React 的文档，发现了很多过去被忽视的细节，所以写下这篇博客。&lt;br&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://code.xnix.me/tags/React/"/>
    
      <category term="doc" scheme="http://code.xnix.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>重读 Redux 源码</title>
    <link href="http://code.xnix.me/2017/11/08/%E9%87%8D%E8%AF%BB-Redux-%E6%BA%90%E7%A0%81/"/>
    <id>http://code.xnix.me/2017/11/08/重读-Redux-源码/</id>
    <published>2017-11-07T16:00:00.000Z</published>
    <updated>2018-04-26T07:59:23.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><a id="more"></a><p>私有变量</p><ul><li>currentReducer 当前的 reducer，用于生成状态树</li><li>currentState 当前状态树</li><li>currentListeners 当前的监听器方法数组</li><li>nextListeners 下一个待执行的监听器方法数组</li><li>isDispatching 在 dispatch 方法中，currentReducer 执行前后的状态。</li></ul><p>私有方法</p><p><code>ensureCanMutateNextListeners</code> 如果在监听器中调用了 dispatch，因为 dispatch 方法也会注意触发之前传入的监听器，为了在新的监听器被加入之前确保当前的监听器数组能够正常被调用，需要拷贝一份监听器。</p><p>共有方法</p><ul><li>getState 获取当前状态树。</li><li>subscribe 通过订阅来监听状态的变化，返回一个 unsubscribe 方法来取消监听。这里添加监听器之前会调用 ensureCanMutateNextListeners 方法。unsubscribe 在移除监听器前也会有同样的拷贝操作。</li><li>dispatch 发送 Action，来改变状态树，然后逐一调用 subscribe 传入的监听器方法。</li><li>replaceReducer 通过替换 reducer 从而生成新的状态树。通常在代码分隔和热加载机制中使用。</li><li>observable 为 observable/reactive 考虑的方法，这里不继续深入。</li></ul><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>合并多个子 reducer 返回一个总 reducer，通过这个返回的 reducer 方法可以得到 state 树。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">  <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">  <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">  <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  nextState[key] = nextStateForKey</span><br><span class="line">  hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure><h2 id="bindActionCreator"><a href="#bindActionCreator" class="headerlink" title="bindActionCreator"></a>bindActionCreator</h2><p>一个便捷方法，返回 Action Creator 方法封装 dispatch 后的对象，后续便可直接调用对象里的方法。一般使用场景，把 Action Creator 下传到子组件上，使子组件无法感知 Redux 的存在。</p><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>联合函数，将多个函数组装成管道传输值。compose(f, g, h) 将会转化为 (…args) =&gt; f(g(h(…args)))。</p><h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">let</span> chain = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch: (...args) =&gt; dispatch(...args)</code> 这段代码对 dispatch 用匿名函数包裹，因为后续 dispatch 会发生更新，使用闭包的好处在于匿名函数内部的 dispatch 会随之更新。</p><p><code>dispatch = compose(...chain)(store.dispatch)</code> 这段代码是最核心。假设 chain 数组为 [f, g, h]，最终会转化为 f(g(h(store.dispatch)))，从右到左执行返回一个新的 dispatch，形成从左向右顺序的调用链。</p><p>中间件格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [middleware name] = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// before</span></span><br><span class="line">  next(action)</span><br><span class="line">  <span class="comment">// after</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于链表，最后的 next 指向 store.dispatch，一个 action 的触发，先经过 middlewares 然后再调用 store.dispatch 改变 state。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;createStore&quot;&gt;&lt;a href=&quot;#createStore&quot; class=&quot;headerlink&quot; title=&quot;createStore&quot;&gt;&lt;/a&gt;createStore&lt;/h2&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://code.xnix.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Redux" scheme="http://code.xnix.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Docker 使用笔记</title>
    <link href="http://code.xnix.me/2017/04/01/Docker-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://code.xnix.me/2017/04/01/Docker-使用笔记/</id>
    <published>2017-03-31T16:00:00.000Z</published>
    <updated>2018-04-26T07:58:29.154Z</updated>
    
    <content type="html"><![CDATA[<p>安装好 docker 后，输入命令<br><a id="more"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看正在运行的 container，更多选项查看 <code>docker ps --help</code></p><h2 id="理解-image-和-container"><a href="#理解-image-和-container" class="headerlink" title="理解 image 和 container"></a>理解 image 和 container</h2><p>image 是静态的，由一个文件系统和一堆参数组成。当 image 被启动后，就被加载到 container。</p><p>当输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>Docker 会如下执行：</p><ul><li>检查本地是否存在 <code>hello-world</code> image</li><li>从 Docker Hub 上下载 image （或者其他 hub）</li><li>加载 image 到 container，并运行</li></ul><p>image 可能运行一个简单的命令然后退出，但也可以启动像数据库这般复杂的程序。使用 Docker，你完全不需要关心运行环境，container 会帮你解决这些问题。</p><h2 id="寻找并运行-image"><a href="#寻找并运行-image" class="headerlink" title="寻找并运行 image"></a>寻找并运行 image</h2><p>Docker 让我们可以创建并且分享 image。就像使用 GitHub 一样，你可以浏览 <a href="https://store.docker.com/community/images/docker/whalesay" target="_blank" rel="noopener">Docker Hub</a> 找到各种你想要的 image。</p><p>类似于上文的 hello world 事例，输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run docker/whalesay cowsay boo</span><br></pre></td></tr></table></figure><p>此时你就运行了一个 whalesay image，执行过程和 hello world 一样，只不过多了一些参数而已。</p><p>当你在 container 中运行 image，Docker 会先将 image 下载到本地，以后再执行此命令，会优先从本地读取。只有hub 上的 image 的发生改变，Docker 才会重新下载。</p><p>如果要查看本地已有的所有 image，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="构建-image"><a href="#构建-image" class="headerlink" title="构建 image"></a>构建 image</h2><p>首先要知道 <code>Dockerfile</code> 的概念，类似于 node 的 <code>package.json</code>，<code>Dockerfile</code> 是一个构建 image 的描述文件。</p><p>在项目目录下，创建一个 <code>Dockerfile</code> 文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FROM 关键字代表基于指定 image 改进，这里我们需要使用 whalesay image 的 cowsay 程序</span></span><br><span class="line"><span class="keyword">FROM</span> docker/whalesay:latest</span><br><span class="line"><span class="comment"># whalesay image 是基于 Ubuntu，所以我们使用 apt-get 来安装包，fortunes 程序会随机输出名人格言</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y update &amp;&amp; apt-get install -y fortunes</span></span><br><span class="line"><span class="bash"><span class="comment"># CMD 命令会在环境设置完毕后执行</span></span></span><br><span class="line"><span class="bash">CMD /usr/games/fortune -a | cowsay</span></span><br></pre></td></tr></table></figure><p>执行命令构建 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t docker-whale-test .</span><br></pre></td></tr></table></figure><p>-t 参数会给 image 打个标记，方便以后运行。不要忘记 <code>.</code> ，表示从当前目录寻找 <code>Dockerfile</code> 文件。</p><p>此时你就可以运行构建好的 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run docker-whale-test</span><br></pre></td></tr></table></figure><p>每次执行都会随机输出一条名言。</p><h2 id="Tag-push-pull-image"><a href="#Tag-push-pull-image" class="headerlink" title="Tag, push, pull image"></a>Tag, push, pull image</h2><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>可以看到 docker-whale-test 的 id</p><p>确保你有 Docker Hub 的账号，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag <span class="variable">$&#123;image id&#125;</span> <span class="variable">$&#123;hub accountname&#125;</span>/docker-whale-test:latest</span><br></pre></td></tr></table></figure><p>再次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>确保 docker-whale-test 已经被打上标签。</p><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>在 push image 到 Docker Hub 之前，你需要登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>在 Docker Hub 站点上创建一个同名仓库，然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push <span class="variable">$&#123;hub accountname&#125;</span>/docker-whale-test</span><br></pre></td></tr></table></figure><p>上传成功后，就可以到仓库首页查看具体信息了。</p><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>上传到 Docker Hub 后，你可以在任何地方通过 <code>docker pull</code> 获取 image。</p><p>首先你要删除本地的备份，否则 <code>docker pull</code> 会认为本地存在指定 image 而不去 Docker Hub 上获取 image。</p><p>通过以下命令删除本地指定 id 的 image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f <span class="variable">$&#123;image id&#125;</span></span><br></pre></td></tr></table></figure><p>使用 <code>docker image rm -f</code> 命令可以批量删除</p><p>最后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="variable">$&#123;hub accountname&#125;</span>/docker-whale-test</span><br></pre></td></tr></table></figure><p>就会自动下载并运行 image</p><h2 id="操作虚拟机"><a href="#操作虚拟机" class="headerlink" title="操作虚拟机"></a>操作虚拟机</h2><p>创建一个本地的虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox <span class="variable">$&#123;MACHINE-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>查看创建完的虚拟机的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine env <span class="variable">$&#123;MACHINE-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>创建完的虚拟机列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p>通过 ssh 访问创建好的虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh <span class="variable">$&#123;MACHINE-NAME&#125;</span></span><br></pre></td></tr></table></figure><h2 id="创建-swarm"><a href="#创建-swarm" class="headerlink" title="创建 swarm"></a>创建 swarm</h2><h3 id="初始化-swarm"><a href="#初始化-swarm" class="headerlink" title="初始化 swarm"></a>初始化 swarm</h3><p>ssh 登录到 manager 虚拟机，执行初始化 swarm 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-add <span class="variable">$&#123;MANAGER-IP&#125;</span></span><br></pre></td></tr></table></figure><h3 id="将-worker-添加到-swarm-中"><a href="#将-worker-添加到-swarm-中" class="headerlink" title="将 worker 添加到 swarm 中"></a>将 worker 添加到 swarm 中</h3><p>在上一步初始化完成后，会输出一个 <code>join</code> 命令。登录到 worker 虚拟机中执行这个命令，命令形式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join \</span><br><span class="line">--token SWMTKN-1-3msallxxbth84sgdvqblncb5915uxwsjv2pc1tsbs3vbv74oms-5xc8gf0cr3731mto8mjltt75x \</span><br><span class="line">192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>你也可以在 manager 虚拟机中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure><p>来重新获取 <code>join</code> 命令。</p><p>在 manager 虚拟机中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure><p>可以查看当前 swarm 中的节点。</p><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>创建一个 <code>docker-stack.yml</code> 文件，并复制到 manager 虚拟机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine scp docker-stack.yml manager:/home/docker/</span><br></pre></td></tr></table></figure><p>进入 manager 虚拟机中执行（之后修改 yml 文件，你也可以执行相同的命令进行重新部署）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy --compose-file docker-stack.yml <span class="variable">$&#123;APP-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>耐心等待创建完毕后，可以通过如下命令确认 stack 是否如期部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack services  <span class="variable">$&#123;APP-NAME&#125;</span></span><br></pre></td></tr></table></figure><h2 id="优雅地关闭，启动和清理应用"><a href="#优雅地关闭，启动和清理应用" class="headerlink" title="优雅地关闭，启动和清理应用"></a>优雅地关闭，启动和清理应用</h2><h3 id="暂停应用"><a href="#暂停应用" class="headerlink" title="暂停应用"></a>暂停应用</h3><p>从 worker 开始使用 <code>docker-machine stop</code> 命令来关闭虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine stop worker</span><br><span class="line">docker-machine stop manager</span><br></pre></td></tr></table></figure><h3 id="重启应用"><a href="#重启应用" class="headerlink" title="重启应用"></a>重启应用</h3><p>从 manager 开始使用 <code>docker-machine start</code> 命令来启动虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine start manager</span><br><span class="line">docker-machine start worker</span><br></pre></td></tr></table></figure><h3 id="移除应用"><a href="#移除应用" class="headerlink" title="移除应用"></a>移除应用</h3><p>登录 manager 虚拟机，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm <span class="variable">$&#123;APP-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>来删除应用以及 manager 和 worker 上相关的所有服务</p><p>通过 <code>docker stack ps ${APP-NAME}</code> 或者 <code>docker stack services ${APP-NAME}</code> 命令确定服务是否全部移除。</p><h3 id="移除虚拟机"><a href="#移除虚拟机" class="headerlink" title="移除虚拟机"></a>移除虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine rm -f worker</span><br><span class="line">docker-machine rm -f manager</span><br></pre></td></tr></table></figure><h2 id="通过默认的网络启动-container"><a href="#通过默认的网络启动-container" class="headerlink" title="通过默认的网络启动 container"></a>通过默认的网络启动 container</h2><p>安装完 Docker 后，自动会包含 3 个默认的网络，可以通过以下命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">66ed589ff017        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">5f904357860e        host                host                <span class="built_in">local</span></span><br><span class="line">e5e8d423a72e        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p><code>bridge</code> 是一个特殊的网络，没有额外的设置，Docker 会默认让 container 使用该网络。</p><p>我们启动一个 ubtuntu image，起一个额外的名字 <code>networktest</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=networktest ubuntu</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e05f4816b60b6e7e7841cef23905fc63d9e2a29f5755b25dac10dc0440a17e5d</span><br></pre></td></tr></table></figure><p>找到容器 IP 地址的一个简单方式就是通过网络监测命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"66ed589ff0170b57ad6fab27cf55d9355a70dad78bf0da9c14f05ec08941635c"</span>,</span><br><span class="line">        <span class="attr">"Created"</span>: <span class="string">"2017-04-01T01:23:09.546974394Z"</span>,</span><br><span class="line">        <span class="attr">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="attr">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="attr">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="attr">"Options"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span>,</span><br><span class="line">                    <span class="attr">"Gateway"</span>: <span class="string">"172.17.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Containers"</span>: &#123;</span><br><span class="line">            <span class="attr">"e05f4816b60b6e7e7841cef23905fc63d9e2a29f5755b25dac10dc0440a17e5d"</span>: &#123;</span><br><span class="line">                <span class="attr">"Name"</span>: <span class="string">"networktest"</span>,</span><br><span class="line">                <span class="attr">"EndpointID"</span>: <span class="string">"9f6bea72c3aca88aa11de0f98068f07fe5ca12d7f254c245745a6b1b09997ab8"</span>,</span><br><span class="line">                <span class="attr">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="attr">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="attr">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Options"</span>: &#123;</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</span><br><span class="line">            <span class="attr">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>用以下命令从网络中来移除一个 container</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect <span class="variable">$&#123;NETWORK-NAME&#125;</span> <span class="variable">$&#123;CONTAINER-ID | CONTAINER-NAME&#125;</span></span><br></pre></td></tr></table></figure><p>如 <code>docker network disconnect bridge networktest</code></p><h2 id="自定义桥接网络"><a href="#自定义桥接网络" class="headerlink" title="自定义桥接网络"></a>自定义桥接网络</h2><p>Docker 原生支持桥接网络（bridge network）和覆盖网络（overlay network）。覆盖网络是更高级的主题，暂时不管。</p><p>创建一个桥接网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge-network</span><br></pre></td></tr></table></figure><p>-d 表示使用 bridge 驱动来创建新的网络。现在用命令 <code>docker netwrok ls</code> 查看下当前所有的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">66ed589ff017        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">5f904357860e        host                host                <span class="built_in">local</span></span><br><span class="line">11de3b834b42        my-bridge-network   bridge              <span class="built_in">local</span></span><br><span class="line">e5e8d423a72e        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>docker network inspect my-bridge-network</code> 命令，很多信息都是空的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"my-bridge-network"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"11de3b834b421ef9bc411867cf67b6f78207f7cdfa12ee83d23cd7c2b0e0ba89"</span>,</span><br><span class="line">        <span class="attr">"Created"</span>: <span class="string">"2017-04-05T02:08:27.299036035Z"</span>,</span><br><span class="line">        <span class="attr">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="attr">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="attr">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="attr">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"Subnet"</span>: <span class="string">"172.18.0.0/16"</span>,</span><br><span class="line">                    <span class="attr">"Gateway"</span>: <span class="string">"172.18.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"Containers"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="将-container-添加到网络中"><a href="#将-container-添加到网络中" class="headerlink" title="将 container 添加到网络中"></a>将 container 添加到网络中</h2><p>container 可以在各自完全独立的网络中运行。</p><p>启动一个运行 PostgreSQL 数据库的 container，并连接到新的网络中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=my-bridge-network --name db training/postgres</span><br></pre></td></tr></table></figure><p>你可以使用 <code>docker network inspect</code> 命令来检测 container 是否加入到网络中。你也可以检测 container 被加入到哪个网络中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;json .NetworkSettings.Networks&#125;&#125;'</span> db</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"my-bridge-network"</span>:&#123;<span class="attr">"IPAMConfig"</span>:<span class="literal">null</span>,<span class="attr">"Links"</span>:<span class="literal">null</span>,<span class="attr">"Aliases"</span>:[<span class="string">"69527e528e38"</span>],<span class="attr">"NetworkID"</span>:<span class="string">"11de3b834b421ef9bc411867cf67b6f78207f7cdfa12ee83d23cd7c2b0e0ba89"</span>,<span class="attr">"EndpointID"</span>:<span class="string">"46d4c9d3f3d84ae9a08dee0a4aea52b42846f684a438e64d6801ea5d2dad51e9"</span>,<span class="attr">"Gateway"</span>:<span class="string">"172.18.0.1"</span>,<span class="attr">"IPAddress"</span>:<span class="string">"172.18.0.2"</span>,<span class="attr">"IPPrefixLen"</span>:<span class="number">16</span>,<span class="attr">"IPv6Gateway"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6Address"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6PrefixLen"</span>:<span class="number">0</span>,<span class="attr">"MacAddress"</span>:<span class="string">"02:42:ac:12:00:02"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们继续启动一个 web 应用，这次不特别指定某个网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web training/webapp python app.py</span><br></pre></td></tr></table></figure><p>检测到使用的是默认的 bridge 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;json .NetworkSettings.Networks&#125;&#125;'</span> web</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"bridge"</span>:&#123;<span class="attr">"IPAMConfig"</span>:<span class="literal">null</span>,<span class="attr">"Links"</span>:<span class="literal">null</span>,<span class="attr">"Aliases"</span>:<span class="literal">null</span>,<span class="attr">"NetworkID"</span>:<span class="string">"66ed589ff0170b57ad6fab27cf55d9355a70dad78bf0da9c14f05ec08941635c"</span>,<span class="attr">"EndpointID"</span>:<span class="string">"16de6cdfdd408b73a82cb222c3d380c71d6d201d3940ab4b2fc0391b33e4bb2d"</span>,<span class="attr">"Gateway"</span>:<span class="string">"172.17.0.1"</span>,<span class="attr">"IPAddress"</span>:<span class="string">"172.17.0.2"</span>,<span class="attr">"IPPrefixLen"</span>:<span class="number">16</span>,<span class="attr">"IPv6Gateway"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6Address"</span>:<span class="string">""</span>,<span class="attr">"GlobalIPv6PrefixLen"</span>:<span class="number">0</span>,<span class="attr">"MacAddress"</span>:<span class="string">"02:42:ac:11:00:02"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>获取 web 的 IP 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;'</span> web</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure><p>使用 <code>docker exec</code> 来在指定的 container 中运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it db bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@69527e528e38:/<span class="comment"># ping 172.17.0.2</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 172.17.0.2 ping statistics ---</span><br><span class="line">9 packets transmitted, 0 received, 100% packet loss, time 8286ms</span><br><span class="line"></span><br><span class="line">root@69527e528e38:/<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><p>因为两个 container 运行在不同的网络中，所以是 ping 不通的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge-network web</span><br></pre></td></tr></table></figure><p>重新进入 db 执行 ping 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it db bash</span><br><span class="line">root@69527e528e38:/<span class="comment"># ping 172.18.0.3</span></span><br><span class="line">PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.159 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.110 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=3 ttl=64 time=0.109 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=4 ttl=64 time=0.109 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.18.0.3 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3127ms</span><br><span class="line">rtt min/avg/max/mdev = 0.109/0.121/0.159/0.025 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好 docker 后，输入命令&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://code.xnix.me/tags/docker/"/>
    
      <category term="note" scheme="http://code.xnix.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>谈谈小影</title>
    <link href="http://code.xnix.me/2016/12/03/%E8%B0%88%E8%B0%88%E5%B0%8F%E5%BD%B1/"/>
    <id>http://code.xnix.me/2016/12/03/谈谈小影/</id>
    <published>2016-12-02T21:12:45.000Z</published>
    <updated>2018-05-21T06:06:08.781Z</updated>
    
    <content type="html"><![CDATA[<p>算上大四 4 月底来小影实习到现在，已经过去了半年多的时间。也见证了小影这短短半年的快速扩张，从 50 人团队发展到百人团队，以及建立北京的分公司，进军中东市场。<br><a id="more"></a><br>和我之前在三江工作有很大的不同。三江购物作为一家上市公司，并且并非传统的互联网公司，公司的运营和管理都十分成熟，在三江工作是十分安逸的。朝八晚六，开发一个项目周期十分充裕，基本上是工作半天玩半天的节奏。作为一个 iOS Developer，在当时我都能够在公司里学习 Angular 2.0 以及 React，顺便还研究了下 Redux 源码。这也为我在后来转行前端的道路上埋下伏笔。</p><p>我在小影目前担任 Web Developer，和之前实习的前端岗位不太相同。在开发前端的同时，还需要完成一些后端服务。所处服务器部门，不可避免地经常听到诸如 Spring、ElasticSearch、大数据分析以及各种数据库知识。在过去开发 iOS 和 Web 前端的过程中是很难去接触太多服务端的东西，除了在大学学的一些 JSP 和 .NET 的课程外，这方面的经验几乎为零。目前慢慢地摆脱前端这个枷锁，也算是实现过去对自己的承诺，多去接触陌生的领域，不要排斥学习新知识的热情。从 iOS 到前端，我已经证明过一次。现在从前端到后端，虽然跨度更大了，但是我也变强了。</p><p>在小影，你有很大的机会去接触一个新的项目，这对一个新人来说是难得的机会。也是我喜欢小公司的一个原因之一。现在在小影担任两个产品都开发，一款是<code>增长黑客</code> - GrowthHacking 项目，用于公司内部数据分析；另一款是<code>小影记</code> - SlidePlus，一款相册 MV 的制作 App。GrowthHacking 是我从无到有一手完成的，虽然目前遇到需要重构整个项目的危机，但是作为我的第一个前端项目，意义重大，迄今为止重构任务已经完成了一半不到，期待明年一个完全不一样的 GrowthHacking。在我加入 SlidePlus Hybrid 开发时，SlidePlus 已经是一个非常成熟的项目了，虽然远不及旗下的 VivaVideo，但是在 App Store 同类产品中甚至排名进前 50。不过也学习到很多可圈可点的东西，关于 Hybrid 开发的技术细节，我可能会在 Github 上专门写一篇文章介绍。</p><p>另一个我比较喜欢小公司的原因就是虽然没有大公司那么正规，但小公司有自己的人情味。这无疑在工作中如同一股清泉一般，尤其是刚毕业还活在象牙塔的傻呆萌大学生。在小影这半年多的时间，大小团建次数我已经记不清楚了，几乎随时都有可能一起聚餐活动。很多朋友一度还以为我每天都在玩。这和我呆了快一年的三江有着很多的不同，在三江的那段时间，我记得就只有一次部门去仙居爬山的活动。同部门绝大部分都是已婚人士，一个小小的实习生也很难融合进去。在小影就完全不一样的氛围，我们部门基本上都是 90 后，平均年龄也就二十四五岁。和一群同龄人工作，有一种后大学时代的即视感。印象最深的一次团建是去舟山住别墅享受海景露天晚餐以及坐游轮出海的那次，以至于我对今年的夏天的印象就是咸咸的海水味和长裙大白腿的视觉享受。</p><p>最后一个比较吸引我的，可能是很多小公司不常有的，就是小影的企业文化。小影是一个全球化战略目标的公司，所以有很多外国留学生过来实习，他们有来自东南亚的，有来自南美的，也有来自中东和欧洲的，而且会在周三的下午茶讲讲自己的国家文化，这可能是我接触到的最直接最原汁原味且最低成本地去感受世界村的途径之一吧。不过最近几次的下午茶变成了创新分享，我是不太感兴趣的。很多技术上所谓的创新，其实就是换汤不换药，而且真要了解技术的创新，并非一次分享会就能学习到的。所以更多情况，我是默默地戴上耳机沉浸在代码世界中。</p><p>当然小影也有太多不足的地方，这是在企业发展道路上不可避免的问题，也不是我现在该抱怨的时候。在以后我会避免无谓的抱怨。我也很为自己现在还没有定型的三观感到悲哀，我不知道这是好事还是坏事，这半年来，每一次总结都感觉是在推翻之前塑造的认知，以至于现在都很难了解自己。这或许可以称之为自我认知的失调吧。不过，我相信多去接触生活，接触未知的领域，超越自身的局限，总会慢慢形成正确的不易受影响的认知。</p><p>这也是为什么我要持续写博客的原因，<strong>让深度地自我思考成为一种生活习惯</strong>。</p><p>最后再上一张前几天再度成为谷歌全球顶尖开发者的庆祝封面。</p><p>Best of 2016. 希望 2017 也能成为最好的我们。</p><p><img src="http://ww1.sinaimg.cn/large/aa0fbcc4gw1fadj1fg9tgj20k00zkq4j.jpg" alt="vivavideo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算上大四 4 月底来小影实习到现在，已经过去了半年多的时间。也见证了小影这短短半年的快速扩张，从 50 人团队发展到百人团队，以及建立北京的分公司，进军中东市场。&lt;br&gt;
    
    </summary>
    
    
      <category term="回顾" scheme="http://code.xnix.me/tags/%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>把最好的一切献给现在</title>
    <link href="http://code.xnix.me/2016/11/17/%E6%8A%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E4%B8%80%E5%88%87%E7%8C%AE%E7%BB%99%E7%8E%B0%E5%9C%A8/"/>
    <id>http://code.xnix.me/2016/11/17/把最好的一切献给现在/</id>
    <published>2016-11-17T07:23:06.000Z</published>
    <updated>2018-05-21T06:00:25.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于编程"><a href="#关于编程" class="headerlink" title="关于编程"></a>关于编程</h2><p>在大学之前，我是完全不懂编程这码事，选择软件工程完全是因为认为自己可以一天到晚在电脑前不觉得累。面对屏幕，再躁动的心也会安静下来。感谢 2012 年那个明智的自己选择的人生道路。如今我已经能靠这项技能生活，已经证明了价值的存在。如果可以，我希望将来可以敲代码到老，或许在未来，编程也会像琴棋书画一般陶冶情操。<br><a id="more"></a><br>有时候看着自己的代码，好像真的赋予了生命一般。严格区分对错，绝不含糊，投入多大的精力就会有多大的回馈。就算你抛弃它，几个月后重新拾起，虽然感到陌生了，但代码还是那份代码，不增不减，你才发现变的原来是自己。甚至抛弃后不再遇见，那份代码依旧保留着你那时的热情和想法，虽然代码会被其它人接手，可能会被改得面目全非，但是在没遇见其他人之前，它可是一直为你保留啊！在某个时间节点之前，可是你全部精力的投入。我想我真的是神经质了，对代码都能产生感情。可想想又能怎样？不高兴了可以敲代码转移注意力，开心了可以敲代码提高效率，落魄的时候可以敲代码励志，无聊的时候可以敲代码解闷，毕竟编程可是你唯一一个没有被抛弃的兴趣。而且这个兴趣，可以为之奋斗，让你过上更好的生活。天下鲜有这般好事了。趁年轻，在迷茫的时候，多敲点代码最是没错的。</p><h2 id="这一年的感想"><a href="#这一年的感想" class="headerlink" title="这一年的感想"></a>这一年的感想</h2><p>明年就要到我的本命年了，2016 眼看就要过去了。又是一个奥运年，从 08 年开始，后来的 12 年，到现在的 16 年，感觉关于过去所有的印象都停留在这三年。</p><p>周围的人换了一批又一批，那些在你生命中出现过的人，都渐渐地断了联系。明明过去可以天天插科打诨，现在连见一面都觉得奢侈。时间对于我们这个年龄段的人来说还是太残酷，我们也不想长大啊！现在每天挤公交，朝九晚八，回家锻炼完后洗个澡就可以睡觉了。这种都市小白领的生活，是绝大部分奋斗在一二线城市的人的写照。这简直是人生的灾难片。甚至至死都没有一声呐喊！</p><p>毕业后一直在思考什么才称得上成熟。是所谓的穿成大人模样，一副久经沧桑的面孔，语重心长地和后辈们讲人生的道理？是所谓的高段位交手，各种套路和人情世故？我想了很久，发现男孩怎么会成熟呢？所谓的成熟，只不过是装给外人看的。小时候几块钱的玩具手枪，到现在上千上万的数码产品，男孩手里的玩具越来越贵，但是不变的是那份玩心。</p><p>这个社会给 90 后贴上了太多标签，但是我们真的是这样吗？我们连自己都不了解自己呀！认为我们吃不了苦，什么是苦？是炎炎烈日下搬砖的汗水？是穷困潦倒街头的缱绻？这些苦难是上几代人绝大部分人所可能经历的。我们难道还要重蹈覆辙吗？这何其不是一种悲哀。我们每一代人奋斗的目标不就是让下一代可以站在自己的肩膀上继续前进吗？我们当然也有不顺心的时候，各种入学考试、求职困难、创业风险，但是我们还是要继续生活下去，因为每个时代的人都不容易，我们别无选择。毕竟未来还是属于我们的，这是对下一代人的负责，也是对自己人生的负责。如果男孩能称得上的成熟，我想也许是因为这份使命感和责任感吧。</p><p>如何从这个时代突围？如何体现自身价值？刚毕业半年不到的我，发现周围很多同学已经将自己的人生定型。我很庆幸我只能看到我未来大约三年的生活，而且这三年还是充满变数。很可能明天就跳槽去了另一家公司，或者换个城市重新生活，抑或是等待机会创业。可能明天永远也猜不透，但是能做的就是时刻为明天做好准备。自身的价值在于稀缺性，你的不可替代属性才是从这个时代突围的关键。我很庆幸毕业后还能认识很多有趣的人，他们的生活方式和工作方式给了我很多启发。从小到大，每一次成长中关键性地洗牌也重新塑造了你的朋友圈，身边的人一直在变也从另一面说明你一直在成长。</p><p>再看看去年的目标：</p><ul><li>将 Swift 投入到 iOS 开发中，能够在 Github 上拥有一个超过三位数的 Star 的 repo。（失败，中途进了前端这艘贼船，不过 Github 数据勉强能看）</li><li>毕业后能够去杭州或者魔都找到一份 iOS 开发的工作。（失败，在杭州找到了一份前端工作）</li><li>能够读完三本以上英文技术书籍并且参加开源社区翻译工作。（彻底的失败，工作了真的觉得这样的时间不多）</li><li>计划一次毕业旅行，没有天数，累了就回来。（Get！毕业旅行去了新疆伊犁，玩得非常开心，希望有机会能再去一次）</li><li>自己配一台电脑，装个 Windows 日常娱乐用。（失败，发现没有买组装机的必要了。）</li><li>购买 Magic Trackpad 2 和 Magic Keyboard 2。（Trackpad 2 目标完成，Magic Keyboard 2 不打算入手，正在观望蓝牙 Filco，留给将来妹子可以当作礼物送给我）</li></ul><p>我发现一个有意思的事情，就是绝大部分目标我是没有实现的，但是依旧很满足，因为这一年里，大部分目标都发生了改变。所以说目标给了你努力的方向，至于是否实现已经意义不大了。在这个过程中，谁知道会不会发现更好的风景呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于编程&quot;&gt;&lt;a href=&quot;#关于编程&quot; class=&quot;headerlink&quot; title=&quot;关于编程&quot;&gt;&lt;/a&gt;关于编程&lt;/h2&gt;&lt;p&gt;在大学之前，我是完全不懂编程这码事，选择软件工程完全是因为认为自己可以一天到晚在电脑前不觉得累。面对屏幕，再躁动的心也会安静下来。感谢 2012 年那个明智的自己选择的人生道路。如今我已经能靠这项技能生活，已经证明了价值的存在。如果可以，我希望将来可以敲代码到老，或许在未来，编程也会像琴棋书画一般陶冶情操。&lt;br&gt;
    
    </summary>
    
    
      <category term="回顾" scheme="http://code.xnix.me/tags/%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于 SlidePlus Hybrid 开发的一些总结</title>
    <link href="http://code.xnix.me/2016/09/12/%E5%85%B3%E4%BA%8E-SlidePlus-Hybrid-%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://code.xnix.me/2016/09/12/关于-SlidePlus-Hybrid-开发的一些总结/</id>
    <published>2016-09-11T16:00:00.000Z</published>
    <updated>2018-04-26T08:25:50.411Z</updated>
    
    <content type="html"><![CDATA[<p>本次总结包括以下几点：<br><a id="more"></a></p><ol><li>前端视频播放的兼容性问题</li><li>Hybrid 开发和调试环境的问题</li><li>Hybrid 的用户体验问题</li><li>Hyrbid 的优缺点</li></ol><h2 id="前端视频播放的兼容性问题"><a href="#前端视频播放的兼容性问题" class="headerlink" title="前端视频播放的兼容性问题"></a>前端视频播放的兼容性问题</h2><p>首先，iPhone 上播放视频方案，我们直接忽略掉 Flash，Safari Mobile 完全不支持。所以重点考虑 HTML5 的方式播放视频，好在 Safari 兼容 video 非常完美。<br>不过又带来另外一个问题，Safari 播放 HTML5 视频，系统会自动放大全屏，即便是使用了 inline 模式，依旧没有效果。<br>再说说 Android 平台上，从下图可以看到 Android 4.4 以上是完美支持 video 的，之前的版本可能存在兼容性，解决方案就是当不支持 HTML5 视频播放时，退一步采用 Flash 方案。但是这也带来另外一个工作量，就是需要完成两套视频播放器界面的 UI。</p><p><img src="https://ww1.sinaimg.cn/large/aa0fbcc4gw1f7r2gl7h8wj20dg0aggmb.jpg" alt="caniuse"></p><p>目前比较好的解决方案是采用 video.js 库，目前还在探索中。</p><h2 id="Hybrid-开发和调试环境的问题"><a href="#Hybrid-开发和调试环境的问题" class="headerlink" title="Hybrid 开发和调试环境的问题"></a>Hybrid 开发和调试环境的问题</h2><p>Native 和 HTML5 通讯主要通过我们搭建的 JSBridge 框架，调用方式主要通过类似如下的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSBridge.call(action, params, callback);</span><br></pre></td></tr></table></figure><p>上面 JSBridge 方式，HTML5 主动调用 Native 提供的接口，可以在 JSBridge 的基础上封装了一层 Promise 解决了回调地狱的问题，让接口调用的方式和前端使用 Fetch 请求网络接口的体验一样，将 Natvie 视为 Server。</p><p>当然我们还有一些业务是需要 Native 主动通知 HTML5 从而更新相关视图。这里 JSBridge 行不通了，我们采用消息发送的机制，Web 端添加监听器，Native 端发送事件以及事件参数。目前业务不太复杂的情况下，处理各类事件还是比较容易控制，接口之间的耦合度也很低。</p><p>在上述情况下，前端开发的体验和前后端分离的思想是类似的。</p><p>接下来说说调试体验，我们的前端是工程化，开发使用的是 ES6 语法，通过编译器转译成 ES5 语法，并通过压缩工具和打包工具，将 CSS 和 JS 导出为单页面应用。这里造成的一个问题就是线上调试异常困难。<br>所以我们一般采用本地调试，主要通过本地开启静态服务，手机通过局域网访问该站点进行调试工作。这样在很多情况下，是没有太大问题的。</p><p>但是由于 SlidePlus 是一款国际化的 App。需要挂载 VPN 模拟海外环境进行调试，这就不可能使用本地调试。目前还没有很好的解决方案，这也是遇到的一个坑。</p><h2 id="Hybrid-的用户体验问题"><a href="#Hybrid-的用户体验问题" class="headerlink" title="Hybrid 的用户体验问题"></a>Hybrid 的用户体验问题</h2><p>用户体验问题是 Hybrid 无法避免的问题，我们能做到的就是无限地去接近原生的体验。</p><p>请求页面的等待时间，这是最大的差异问题。<br>考虑在无网络和网络情况糟糕的情况下，不再请求服务器，而是使用本地预存好的静态页面。<br>为了保证网络访问情况在绝大部分情况下良好，国内采用阿里云的 CDN 加速，国外采用 Akamai CDN 加速。<br>为了减少请求流量，使用缓存和 ETag，基本优化方式和传统 Web 开发一致。<br>同时我们是单页面的概念，也就是说，第一次加载到网页后续的操作抛开请求接口的情况，基本都不需要请求网络，在一定程度上避免了频繁请求网络带来的延迟问题。<br>最后就是采用全站 https 方案解决运营商劫持的问题。（采用 https，在请求时会多了握手的链接，所以请求时间会略微变长）。还有一个 https 的坑，就是 Web 端请求 rpc 接口，收到的图片链接为 http 协议，这样会带来安全性问题，有些浏览器就会拒绝发出 http 请求，造成一些意外的问题。</p><p>浏览器视图渲染的等待时间，我们需要做到尽量少的操作 DOM，在不可避免的情况下，可以考虑合并多次操作 DOM 的行为，一次性操作。对于频繁操作 DOM 的地方，我们需要将行为缓存起来。<br>遇到无限滚动列表滑动，在 Android 会出现整屏空白的情况，这里我采用的是使用 <strong>* requestAnimationFrame</strong>* 一个提供了一个统一帧管理、提供监听帧的 API。该接口的好处，对于一个侦中对DOM的所有操作，只进行一次Layout和Paint；如果发生动画的元素被隐藏了，那么就不再去Paint。</p><p>在 Web 端，点击事件通常响应比原生慢很多，采用 fastclick 库可以非常好的避免这种问题。以及长按文本会弹出复制粘贴的菜单栏，这些我们都可以通过下面的 css 解决。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span>: <span class="selector-tag">none</span>;<span class="comment">/*禁用手机浏览器的用户选择功能 */</span></span><br><span class="line"><span class="selector-tag">-moz-user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h2 id="Hyrbid-的优缺点"><a href="#Hyrbid-的优缺点" class="headerlink" title="Hyrbid 的优缺点"></a>Hyrbid 的优缺点</h2><p>首先，至少在项目的初期，Hybrid 开发并没有 Native 开发那么快速，一堆无法预见的坑需要解决。</p><p>然后接口调试较以往比较困难，遇到一些问题都是在摸索中爬行，很多时候一个问题需要在 Web 端和 Native 端两边都排查一遍才能找到。</p><p>当然这些问题当 HTML5 容器逐渐成熟起来，把该爬到坑都爬过，后续 Native 端端开发会越来越轻松，一些业务代码可以迁移到 Web 端，在不发布新版本的情况下也可以很大自由地修改或增加一些需求，整个开发流程也会越来越灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次总结包括以下几点：&lt;br&gt;
    
    </summary>
    
    
      <category term="Hybrid" scheme="http://code.xnix.me/tags/Hybrid/"/>
    
      <category term="SlidePlus" scheme="http://code.xnix.me/tags/SlidePlus/"/>
    
  </entry>
  
  <entry>
    <title>剖析 Promise 内部机制</title>
    <link href="http://code.xnix.me/2016/07/21/%E5%89%96%E6%9E%90-Promise-%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://code.xnix.me/2016/07/21/剖析-Promise-内部机制/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2018-04-26T08:26:07.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从回调地狱说起-Callback-Hell"><a href="#从回调地狱说起-Callback-Hell" class="headerlink" title="从回调地狱说起 Callback Hell"></a>从回调地狱说起 Callback Hell</h2><a id="more"></a><p>在 Node 中，绝大部分操作都是异步的方式，例如读取一个文件内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./config/pass.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们通过传入一个回调函数作为异步完成的后续操作。</p><p>如果我们异步读取多个文件，等到所有文件读取完毕执行特定操作呢？<br>代码修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./config/pass.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  fs.readFile(<span class="string">'./config/pass1.txt'</span>, (err, data1) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    fs.readFile(<span class="string">'./config/pass2.txt'</span>, (err, data2) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">      fs.readFile(<span class="string">'./config/pass3.txt'</span>, (err, data3) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里还是简单地敲套三层，想象下业务突然复杂，一不小心嵌套五层以上，这画面太美。。。</p><h2 id="救世主-Promise"><a href="#救世主-Promise" class="headerlink" title="救世主 Promise"></a>救世主 Promise</h2><blockquote><p>Promise 的音译是普罗米修斯，是希腊神话故事中的英雄，名字的意思是“先知”。</p></blockquote><p>我们可以把上面 Node 读取文件的操作改造如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncReadFile</span> (<span class="params">filePath, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filePath, options, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看 Promise 是如何解决 Callback Hell 的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile(<span class="string">'./config/pass.text'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/pass1.text'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/pass2.text'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/pass3.text'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>对于先知的我们，故事的安排在脑中是即时出现的，而非实际上的异步发生。因此，作为创世的编程者而言，这种与瞬间思考所同步的代码更符合现实世界下的思考方式。因此，更易读更易于理解。</p></blockquote><p>Promise 是一种对异步操作的封装，在异步操作执行成功或者失败时执行指定方法。将横向的异步调用转换为纵向，因此更符合人类的思维方式。</p><p>一个 Promise 对象具备三种生命状态：pending、fulfilled 和 rejected。只能从最初的 pending 到 fulfilled 或者 rejected，而且状态的改变是不可逆的。</p><p><img src="https://ww3.sinaimg.cn/large/aa0fbcc4gw1f61u9ne8d1j208u04umxc.jpg" alt="pending"></p><p>我们先简单看下 Promise 的工作原理。</p><p><img src="https://ww4.sinaimg.cn/large/aa0fbcc4gw1f61u4fuaf0j20jc07b74z.jpg" alt="promise"></p><p>Promise 大致的工作流程是：</p><ul><li>创建 Promise 对象 =&gt; 进入等待处理阶段 Pending</li><li>处理完成后，切换到 Fulfilled 状态／ Rejected 状态</li><li>根据状态，执行 then 方法／执行 catch 方法 内的回调函数</li><li>then 方法返回新的 Promise，此时就支持链式调用</li></ul><p>这里创建一个 Promise 对象，Promise 内部维系着 resolve 和 reject 方法，resolve 会让 Promise 对象进入 Fulfilled 状态，并将 resolve 方法的第一个参数传给后续 then 所指定的 onFulfilled 函数。reject 方法同理，只不过是切换到 Rejected 状态，并将参数传给 catch 所指定的 onRejected 函数。</p><h2 id="一步步打造心中的-Promise"><a href="#一步步打造心中的-Promise" class="headerlink" title="一步步打造心中的 Promise"></a>一步步打造心中的 Promise</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>先抛开 rejected，实现一个 Promise 的调用链的简单代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferreds = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    deferreds.push(onFulfilled)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    deferreds.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">      deferred(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入理解上面代码逻辑：</p><ul><li>then 方法将 onFulfilled 函数压入 deferreds 队列中。</li><li>将 resolve 传给创建 Promise 时传入的函数，resolve 的作用是将 deferreds 中的 onFulfilled 函数队列逐一执行。</li></ul><p>但是这段代码暴露出一个严重的问题，如果 Promise 执行的是同步代码，resolve 是早于 then 方法的执行，这样造成一个问题：<strong>then 还没有及时把 onFulfilled 函数压入队列，此时 deferreds 还是空数组，resolve 执行后，后续注册到 deferreds 数组内的 onFulfilled 函数将不再执行。</strong></p><p>这里我们可以把 deferreds 数组视为水桶，onFulfilled 视为饮用水，resolve 视为开关。then 操作就是将饮用水一点点地注入到水桶中。想想我们还没将水加到水桶中（执行 then 操作）就打开开关（执行 resolve），这肯定是接不到水的。</p><p>解决的办法就是将 resolve 函数的执行改为异步。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>Promises/A+ 规范明确要求回调需要通过异步方式执行，保证一致可靠的执行顺序。通过 setTimeout 方法，我们可以轻松实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    pending.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">      deferred(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以把 resolve 执行放到下一个时钟周期。</p><h3 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h3><p>按照 Promise 规范，我们需要引入三种互斥的状态：pending、fulfilled、rejected。</p><p><img src="https://ww3.sinaimg.cn/large/aa0fbcc4gw1f61u9ne8d1j208u04umxc.jpg" alt="status"></p><p>执行 resolve 会将 pending 状态切换到 fulfilled，在此之后添加到 then 到函数都会立即被调用。</p><p>现在我们的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deferreds = []</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferreds.push(onFulfilled)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    onFulfilled(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">_value</span>) </span>&#123;</span><br><span class="line">    state = <span class="string">'fulfilled'</span></span><br><span class="line">    value = _value</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      deferreds.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">        deferred(value)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的基础，我们可以简单地调用 Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile(<span class="string">'./README.md'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了串行 Promise，我们在 then 中返回 this，并设置一个 value 来保存传给 resolve 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile(<span class="string">'./README.md'</span>, <span class="string">'utf-8'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./package.json'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>像上面这样调用，虽然可以通过，但是两次输出的 data 是相同的值，并不是真正意义上的链式调用。</p><h3 id="串行-Promise"><a href="#串行-Promise" class="headerlink" title="串行 Promise"></a>串行 Promise</h3><p>只要 then 方法每次调用都返回一个 Promise 对象，前一个 Promise 对象持有后一个 Promise 对象的 resolve 方法，这样串行就变得非常简单了。</p><p>这里需要对 then 方法进行改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    handle(&#123; onFulfilled, resolve &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    deferreds.push(deferred)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ret = deferred.onFulfilled(value)</span><br><span class="line">  deferred.resolve(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完成的主要任务是：</p><ul><li>then 方法中返回一个新的 Promise 对象，这样每次执行 then 方法，都返回一个 Promise 对象，让链式调用成为可能。</li><li>新创建的 Promise 对象调用上一级 Promise 的 handle 方法，传递自身的 resolve 方法和当前的 onFulfilled 函数。</li></ul><p>handle 相比之前的 then 多了一行 <code>deferred.resolve(ret)</code>，这一步是链式调用的关键点。此刻的 resolve 是下一级 Promise 的方法，上一级 Promise 执行这段方法调用，就开启了链式调用。</p><p>我们继续重构前面的 Promise 代码，这里主要修改的是 resolve 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deferreds = []</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then 方法永远会返回一个 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// handle 为上一级 Promise 的方法</span></span><br><span class="line">      handle(&#123; onFulfilled, resolve &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// then 方法将 deferred 传入时，先压入到 deferreds 中</span></span><br><span class="line">      deferreds.push(deferred)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 Bridge Promise 前一个 Promise 对象的 then 方法的 onFulfilled 函数</span></span><br><span class="line">    <span class="keyword">const</span> ret = deferred.onFulfilled(value)</span><br><span class="line">    <span class="comment">// resolve 执行 deferreds 中的 onFulfilled 方法，即下一个 Bridge Promise 的 then 中的回调函数</span></span><br><span class="line">    deferred.resolve(ret)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">_value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是 promise 对象</span></span><br><span class="line">    <span class="keyword">if</span> (_value &amp;&amp; (<span class="keyword">typeof</span> _value === <span class="string">'object'</span> || <span class="keyword">typeof</span> _value === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> then = _value.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 resolve 延迟到 promise 执行完毕后调用，切换 Bridge Promise 的状态。</span></span><br><span class="line">        then.call(_value, resolve)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是其它值</span></span><br><span class="line">    state = <span class="string">'fulfilled'</span></span><br><span class="line">    value = _value</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      deferreds.forEach(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">        handle(deferred)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-具体流程"><a href="#Promise-具体流程" class="headerlink" title="Promise 具体流程"></a>Promise 具体流程</h2><ol><li>实例化一个最初的 Promise 对象，设置最初的状态为 <code>pending</code>。</li><li>通过 then 方法，创建一个新的 Promise 对象，由于上一级 Promise 暂时处于 pending 状态，当前 then 方法的 onFulfilled 函数和新 Promise 的 resolve 方法放入到上一级 Promise 的 deferreds 数组中。</li><li>这样就形成这样一个画面：<strong>第一个 Promise 被实例化，调用 then 方法。then 会返回一个新的 Promise 对象，在上一个 then 方法的基础上继续通过新 Promise 的 then，形成一条调用链。<br>每一个被创建出来的新 Promise 的 resolve 都将传给上一级的 Promise 的 deferreds 数组来维护</strong></li><li>在第一个 Promise 对象的回调函数中执行异步操作，完成后调用 Promise 的 resolve 方法。</li><li>resolve 允许传入一个参数，该参数的值通过 Promise 内部的 value 变量维护。resolve 会把 Promise 的状态修改为 <code>fulfilled</code>，然后异步调用 handle 依次处理 deferreds 数组中的每一个 deferred。</li><li>此时第一个 Promise 的状态在上一步骤中被改为 fulfilled，于是 handle 主要完成的工作是，执行 deferred 的 onFulfilled 函数，并调用下一个 Promise 的 resolve 方法。</li><li>下一个 Promise 的 resovle 在上一级被执行成功后，同样会将状态切换到 <code>fulfilled</code> ，重复步骤 6 直到结束。</li></ol><p>这样 Promise 的核心逻辑，基本被我们实现了。至于 rejected 和 异常处理 就交给大家来思考吧（其实就是懒！）。</p><p>结束语：真的很难想象就这么几十行代码，竟然有如此强大的威力，理解 Promise 并不难，需要敬佩的是创造强大 Promise 魔法的第一批程序员。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从回调地狱说起-Callback-Hell&quot;&gt;&lt;a href=&quot;#从回调地狱说起-Callback-Hell&quot; class=&quot;headerlink&quot; title=&quot;从回调地狱说起 Callback Hell&quot;&gt;&lt;/a&gt;从回调地狱说起 Callback Hell&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Promise" scheme="http://code.xnix.me/tags/Promise/"/>
    
      <category term="源码" scheme="http://code.xnix.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hybrid App 优化笔记</title>
    <link href="http://code.xnix.me/2016/06/01/Hybrid-App-%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
    <id>http://code.xnix.me/2016/06/01/Hybrid-App-优化笔记/</id>
    <published>2016-05-31T16:00:00.000Z</published>
    <updated>2018-04-26T08:25:34.433Z</updated>
    
    <content type="html"><![CDATA[<p>混合型 App 优化的地方需要注意的细节有挺多地方，这里我把自己未来这一个月的工作感受都汇总到这里，方便大家参考。<br><a id="more"></a></p><h2 id="框架的选择"><a href="#框架的选择" class="headerlink" title="框架的选择"></a>框架的选择</h2><p>技术选型上，我对比了 Angular、React 和 Vue 三个框架。Angular 1.x 版本性能问题和大体积带来的流量问题第一个被我放弃掉，4月初我有学习过 Angular 2.0，相对于 1.x 版本有了很大的进步，但是考虑到依旧处于 Beta 版本，不敢冒险投入到生产环境中。</p><p>React 是个非常好的框架，可能是从 iOS 转过来的缘故吧，JSX 语法并没有那么反人类，而且在刚来小影的第一个项目就是用 React + Ant + Koa 这套技术栈基本完成了 Growth hacking 的数据报表页面的雏形。整个开发过程并没有遇到特别大的问题，基本上官方文档也写得足够详细。如果作为移动开发，React 是一个好的选择。但是就来说说这次为什么选择 Vue 的原因，首先 React 是通过重新修改 Vitural DOM ，然后和原生 DOM 进行 diff 比较，修改不同的节点这样一个工作原理。这里带来了一个问题就是直接操作原生 DOM 不是特别方便，虽然有 refs 和 findDOMNode 这些方式，但是写起来感觉还是不够优雅，而且这样就完全享受不到 Vitural DOM 带来的好处。第二个原因就是 React 是单向数据流，这样做看起来业务逻辑更加清晰，其实间接地带来另一个坑，就是不好管理各个组件的状态，而且组件之间的交互也变得困难。虽然 Flux 规范的框架一定程度上缓解了问题，但是同样带来了学习的成本。Redux 实现 FLux 规范，统一通过 state tree 来管理状态，每个行为触发一个 action，dispatch 分发 action 从而 reduce 出一个新的 state，state 一旦发生变化，就带来视图的重新渲染。上面这一套流程，对于刚接触 Redux 的童鞋来说，多少会有点懵逼。<br>最后说说我为什么选择 Vue，首先 Vue 是 MVVM 框架，双向绑定非常便捷，但是底层实现通过将普通 data 改造为 getter/setter 的属性的 data，然后通过一个 watcher 当做 DOM 和 Model 之间的媒介，从而达到一旦数据发生改变就通知视图重新渲染，视图上修改的数据同样反向通知 Model 进行同步修改。这样维护视图数据就变得非常轻松。然后一个原因就是 Vue 足够的轻量，而且性能突出。这两个特点简直太适合移动端的开发，流量是非常重要的一个因素，作为用户，谁也不希望打开一个页面需要加载好几MB的资源文件吧。和 App 合作的童鞋的要求就是一个页面尽量不要超过 200 kb。在流量方面后续还会有更多要讲，这里就点到为止。<strong>其实性能不是体现在 JS 的执行上，而是体现在 DOM 操作上.</strong>Vue 在 DOM 渲染上的优化工作实现起来非常简单，主要优化体现在标记重用组件等，官方文档有详细说明，这里不再赘述。总之，Vue 既有 Angular 的 MVVM 实现，也有指令、过滤器等特性，同时有像 React 的组件化开发体验，而且比 Angular 轻量灵敏、比 React 更方便操控 DOM。这就是我选择 Vue 的原因。</p><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>首先我们要知道 Hybrid App 的一套工作流程，Hybrid App 并非套壳浏览器这么简单。Native 层会构造出一个容器，用来呈现静态网页。这个容器内部有一个浏览器，一般内核为 Webkit。容器载入静态网页后，会注入一段 JS 脚本，通过这个脚本来实现 Native 和 JS 的交互。Native 这边预先设置原生 API 的接口，Web 层通过注册相应的事件，触发对应的回调函数。这样 JS 就能够完成像调用物理设备、唤起 Toast 等原生视图的效果。</p><p>Hybrid 最简单的实现就是每次 App 启动就请求静态服务器，获取静态 HTML5 页面。后期需要更新 App，只需更新这个静态页面就可以了。但是这里就带来了一个问题就是，每次用户都需要请求静态页面，如果页面没有更新就会造成流量浪费的情况。解决这个问题的方案就是使用缓存，图片资源尽量借助 Native 的二级缓存机制，加载图片依次从内存、磁盘上查找，依旧没有才继续发送网络请求，然后将请求到的图片缓存到内存和磁盘中，供下次查找，同时配合 LRU 替换算法提高缓存命中和空间优化。好在上面的实现方案很多第三方框架已经帮我们解决，iOS 平台例如 SDWebImage、YYImage 等都是非常好的轮子。</p><p>其他非图片的静态资源，比如 Vue 打包后的 js 以及 css 文件也大概有 200 kb 左右的资源，这里我们让它第一次请求后就缓存本地后，以后请求通过 etag 标签进行校验是否改动，没有修改则返回 304 然后从 cache 中读取，否则请求新的资源。etag 只需要服务器配置下，Native 端的 WebView 应该会自动实现此机制。这样可以将后续请求的流量从大概 200 kb 降到 1kb 不到。</p><p>下面是优化前后的对比情况：</p><p><img src="https://ww2.sinaimg.cn/large/aa0fbcc4gw1f4h6jzvyqcj20fs03pwf3.jpg" alt="before"></p><p><img src="https://ww2.sinaimg.cn/large/aa0fbcc4gw1f4h6l8b67jj20fs03qjry.jpg" alt="after"></p><p>可以看出加了 etag 后，不仅流量节省了，同时响应速度也快了不少。但是这里我们还需要注意到的情况就是即使这些静态资源没有被修改，但是我们还需要每次都请求网络来验证是否修改，虽然每次请求的数据量很小，但是还是可以继续优化。那就是适当地添加缓存过期时间，因为一般情况下我们不会每时每刻改变静态资源，这时候在添加 Cache-Control 或者 Expires ，让客户端在短时间内暂时从缓存中获取数据。</p><p>一些静态页面我们甚至不需要请求网络，只需要保存到本地，每次 WebView 启动都去本地目录下找到静态页面并渲染。这样基本可以做到秒开而且无流量消耗。至于更新本地的目录，只需要做到当 App 启动时，从服务器获取到校验码来校验是否改变从而选择是否更新即可。</p><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ul><li>不要忘记开启 GZip 压缩。</li><li>打包压缩 CSS 和 JS，减少请求次数。</li><li>开启 CDN 加速。</li><li>请求服务使用 IP 而非域名，去除 DNS 解析环节。</li><li>使用首屏加载。</li><li>按需加载资源。</li><li>如果有大量列表，使用滚屏加载。</li><li>减少 Cookie。</li><li>减少甚至不要重定向。</li><li>技术上尽量做到使用 WebP 格式的图片。</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>尽量少使用动画，毕竟所谓 Hybrid App 就是一个扬长避短的方案， Native 和 Web 各自发挥长处，相互弥补短处。Web 端不需要实现过多华丽的动画，这本身就是对性能的极大考验，即使要用也使用 CSS 动画，做到硬件加速。一些转场动画我们可以通过 JS 调用 Native 接口实现，不过依旧不太推荐过于丰富的动画效果。<br>资源加载方面，使用延迟加载，让屏幕之外的资源加载时间推移到首屏界面加载完毕后。对于加载时间过长的情况，使用进度条给用户一种期盼感，否则用户长时间面对无交互的屏幕会产生焦虑感从而关闭 App。<br>至于框架优化，在 Vue 里需要注意的地方就是列表重用即可。其它大部分优化 Vue 的作者已经做得很好，在某些方面是完全碾压 React 的。<a href="https://engineering.footballradar.com/from-a-react-point-of-vue-comparing-reactjs-to-vuejs-for-dynamic-tabular-data/" target="_blank" rel="noopener">可以参考两者的性能对比</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;混合型 App 优化的地方需要注意的细节有挺多地方，这里我把自己未来这一个月的工作感受都汇总到这里，方便大家参考。&lt;br&gt;
    
    </summary>
    
    
      <category term="Hybrid" scheme="http://code.xnix.me/tags/Hybrid/"/>
    
      <category term="优化" scheme="http://code.xnix.me/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>2015 尾声</title>
    <link href="http://code.xnix.me/2015/12/30/2015-%E5%B0%BE%E5%A3%B0/"/>
    <id>http://code.xnix.me/2015/12/30/2015-尾声/</id>
    <published>2015-12-30T05:08:52.000Z</published>
    <updated>2018-05-21T06:05:10.936Z</updated>
    
    <content type="html"><![CDATA[<p>最近一次静下来整理年终的文章已经是2012年的事情了，那一年发生的事情挺多的，高考、大学、世界末日、伦敦奥运会，算是人生中印象较深的一年吧。<br>写总结前，特意翻了下好几年前中学时代空间里的日志，很多日志不知道什么时候被删除了，现在想来还是很可惜的一件事情。遗忘的那段记忆，就好像从来没发生过一样。</p><p>现在虽然还有保持写博客的习惯，但是写的多是质量不高的技术博客。至于年终总结，大学就像是复制粘贴一样过着就到了大四，每天浑浑噩噩，完全没有什么可写的。<br>这可能是大学时代最后一次写总结了，所以就当时是给自己一个交代吧。<br><a id="more"></a></p><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>首先从年初说起，大三下学期刚开学，直接抛弃了第一家实习公司。那段实习经历以浪费时间总结，一个创业小公司，老板想把你培养成全栈，一会学这一会学那。最后把自己学得越来越浮躁，什么都懂什么都不精，写代码眼高手低。<br>之后老老实实地在学校呆了一学期，现在回顾下，大学还是一个让心静下来的好地方。不需要金钱利益，不需要阿谀奉承，几个小伙伴有一个共同爱好，单纯地投入其中，不用想以后生活的压力。除了大学时代，将来的人生估计再也不会有这种体验了。</p><p>期间学习了 Node.js，一下子感觉打开了一扇大门，MongoDB、Redis、Angular.js等一堆东西出现在学习中。你突然地发现学校学的东西简直就是活化石，dot Net 三层架构、JSP这些东西后来和我的技术老大一交流，感觉我在他心中的形象都打了对折。<br>有一次 JSP 的课上，我写完作业在那看《Node学习指南》，老师走过来和我讨论了下，他竟然还停留在 JS 就是用于表单验证的，简单操作 HTML。当知道 JS 可以写服务器的时候，他还评论性能应该不好。</p><p>我这里不是吐槽这位老师，老师以教书为主，且平时的工作重点都是放在学校的学科竞赛，学术论文上。IT 行业脱轨一两年就感觉隔了一个世纪的也是见怪不怪的事了。毕竟人家教 JSP 真的很有耐心，也很负责任。解释一些原理，不会教你如何 copy 代码。</p><p>这个暑假也没有回家，找到了第二家实习单位，三江购物。三江是个好公司，正在转型电商。团队是从外面挖来的，苏宁国美的都有。技术老大是个非常牛的人物，人很好挺有逼格。最近产品就要上线了，团队上下都挺忙的，所以我 Github 上基本开始一片灰的节奏。<br>开发三江 iOS 学到的东西比过去一年学到的都多，如果将来个人开发新的 App 的话，绝对不再以 Objective-C 为主，Swfit 才是趋势。架构非常重要！希望可以早点学会 VIPER 的思想。接口规范也非常重要！目前三江的接口还是存在很大问题的，没有很好地遵守 Restful 规范，导致现在业务逻辑衔接起来混乱，为了赶项目也只能暂时妥协。</p><p>这一年我的生产环境完全转到了 Unix Like 下，我已经很久没碰过 Windows 系统了，当初感觉高大上的 OS X 系统，现在已经不再陌生而且渐渐离不开的节奏。那种合上盖子就走人，打开盖子就工作的感觉非常棒。一个月不关机，持久的续航能力，最重要的是 Retina 屏幕完全就是视觉享受。当然这些硬件条件并不能媲美 OS X 系统，比 Linux 少很多折腾，又拥有和 Linux 相同体验的开发环境，终端敲命令行的酸爽也是在 Windows 下体验不到的。总之，对于程序员来说，我是十分推荐用 OS X。仅限程序员！</p><p>还有一个值得自豪的事情就是从暑假开始，我已经不用靠父母的生活费过日子了。没了父母给的零花钱，过得还是挺穷的，然后又改不了以前大手大脚地买电子产品的习惯，经常靠朋友借钱活下去。在这里感谢下我周围的土豪朋友，和你们做朋友真好。<br>到现在，靠自己赚的钱换了手机，买了个 Apple Watch，然后还幸福地生活下去。那种感觉比父母给你买个 MacBook 好一万倍。</p><p>可能是因为未来职业的问题或者被知乎和微博输入各种三观，过去使用收费软件一般都是装破解版，运气不好还附带个百毒全家桶，浪费很多时间，体验也十分糟糕。第一次在 App Store 买了几款不错的 App 后，发现买软件花费的钱也就是你一杯咖啡的价格，然而少了很多来自盗版的危害和折腾。国人还有很多没有知识产权的意识，他们认为这些东西免费才是天经地义。我不是来吐槽那些用盗版的人，也不是彰显自己的优越感。我只是想说，用正版并没有想象中的贵，你花的那些钱是值得的，不信你们试试。如今我想听音乐就订阅 Apple Music，想看东野奎吾就在 iBook 上购买，想玩游戏就 Steam 上付费，即使网上有非法高清的《火星救援》还是选择去电影院观看。这是对作者的尊重和支持，这样他们才有更多的动力提高用户体验，创造更多更有意义的东西。</p><h2 id="Stay-hungry-stay-foolish"><a href="#Stay-hungry-stay-foolish" class="headerlink" title="Stay hungry, stay foolish"></a>Stay hungry, stay foolish</h2><p>我一直让自己对喜欢的事物保持新鲜感，我想如果你连自己喜欢的东西都失去了兴趣，那么你的生命也从此是一片黑白。就像我非常喜欢苹果，我有钱就会买能力范围内最新的苹果设备，同时大学也是自学 iOS，还靠这门技术养活自己。世界上最幸福是莫过于做自己喜欢的事情还有钱赚。我非常喜欢编程，虽然通常很懒，但依旧对新知识的充满激情。很喜欢和专业的人讨论技术，即便对于现在的我讨论的话题质量不会太高，但是我还是保持强大的兴趣，尤其是很大牛们一起。我应该不是最有天赋的，也不是最勤奋的，但是我会保持最大的新鲜感去拥抱编程，即使是退休躺在家里，我依旧还会编程，将自己的想法通过代码告诉计算机。</p><p>然而我一直不认为我是个谦虚的人，可能是青春期的年少轻狂还在，不过慢慢地收敛很多。我知道世界上很多伟大的人，都是默默无闻孜孜不倦的努力着。我们真的没有太多可以骄傲的资本，我们现在能做到的就是怀着敬畏的态度回馈社会。</p><p>Stay hungry，stay foolish。这是帮主生前在斯坦福演讲中提到的，也是我的座右铭。我想我还是只体会到这句话的字面意识，深层意思在工作和学习中寻找吧。</p><h2 id="Next-year"><a href="#Next-year" class="headerlink" title="Next year"></a>Next year</h2><p>展望 2016，这个时候应该开始填写未来的计划和愿望。下面就列个清单，等一年后再回来看看。</p><ul><li>将 Swift 投入到 iOS 开发中，能够在 Github 上拥有一个超过三位数的 Star 的 repo。</li><li>毕业后能够去杭州或者魔都找到一份 iOS 开发的工作。</li><li>能够读完三本以上英文技术书籍并且参加开源社区翻译工作。</li><li>计划一次毕业旅行，没有天数，累了就回来。</li><li>自己配一台电脑，装个 Windows 日常娱乐用。</li><li>购买 Magic Trackpad 2 和 Magic Keyboard 2。</li></ul><p>目前就想到这么多，都能实现也算圆满了。</p><p>嗯，2015年眼看就有结束了，被偷走的岁月无法重新来过，珍惜当下，珍惜家人。共勉！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一次静下来整理年终的文章已经是2012年的事情了，那一年发生的事情挺多的，高考、大学、世界末日、伦敦奥运会，算是人生中印象较深的一年吧。&lt;br&gt;写总结前，特意翻了下好几年前中学时代空间里的日志，很多日志不知道什么时候被删除了，现在想来还是很可惜的一件事情。遗忘的那段记忆，就好像从来没发生过一样。&lt;/p&gt;
&lt;p&gt;现在虽然还有保持写博客的习惯，但是写的多是质量不高的技术博客。至于年终总结，大学就像是复制粘贴一样过着就到了大四，每天浑浑噩噩，完全没有什么可写的。&lt;br&gt;这可能是大学时代最后一次写总结了，所以就当时是给自己一个交代吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="回顾" scheme="http://code.xnix.me/tags/%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
</feed>
